{"version":3,"sources":["../src/index.ts","../src/strategies/context/IContextFetchingStrategy.ts","../src/utils/IdentifyThrottler.ts","../src/strategies/context/SimpleContextFetchingStrategy.ts","../src/strategies/context/WorkerContextFetchingStrategy.ts","../src/strategies/sharding/WorkerShardingStrategy.ts","../src/strategies/sharding/SimpleShardingStrategy.ts","../src/ws/WebSocketShard.ts","../src/utils/constants.ts","../src/ws/WebSocketManager.ts"],"sourcesContent":["export * from './strategies/context/IContextFetchingStrategy.js';\nexport * from './strategies/context/SimpleContextFetchingStrategy.js';\nexport * from './strategies/context/WorkerContextFetchingStrategy.js';\n\nexport * from './strategies/sharding/IShardingStrategy.js';\nexport * from './strategies/sharding/SimpleShardingStrategy.js';\nexport * from './strategies/sharding/WorkerShardingStrategy.js';\n\nexport * from './utils/constants.js';\nexport * from './utils/IdentifyThrottler.js';\n\nexport * from './ws/WebSocketManager.js';\nexport * from './ws/WebSocketShard.js';\n\n/**\n * The {@link https://github.com/discordjs/discord.js/blob/main/packages/ws/#readme | @discordjs/ws} version\n * that you are currently using.\n */\n// This needs to explicitly be `string` so it is not typed as a \"const string\" that gets injected by esbuild\n// eslint-disable-next-line @typescript-eslint/no-inferrable-types\nexport const version: string = '0.6.0';\n","import type { Awaitable } from '@discordjs/util';\nimport type { APIGatewayBotInfo } from 'discord-api-types/v10';\nimport type { SessionInfo, WebSocketManager, WebSocketManagerOptions } from '../../ws/WebSocketManager';\n\nexport interface FetchingStrategyOptions\n\textends Omit<\n\t\tWebSocketManagerOptions,\n\t\t'rest' | 'retrieveSessionInfo' | 'shardCount' | 'shardIds' | 'updateSessionInfo'\n\t> {\n\treadonly gatewayInformation: APIGatewayBotInfo;\n\treadonly shardCount: number;\n}\n\n/**\n * Strategies responsible solely for making manager information accessible\n */\nexport interface IContextFetchingStrategy {\n\treadonly options: FetchingStrategyOptions;\n\tretrieveSessionInfo(shardId: number): Awaitable<SessionInfo | null>;\n\tupdateSessionInfo(shardId: number, sessionInfo: SessionInfo | null): Awaitable<void>;\n\twaitForIdentify(): Promise<void>;\n}\n\nexport async function managerToFetchingStrategyOptions(manager: WebSocketManager): Promise<FetchingStrategyOptions> {\n\t// eslint-disable-next-line @typescript-eslint/unbound-method\n\tconst { retrieveSessionInfo, updateSessionInfo, shardCount, shardIds, rest, ...managerOptions } = manager.options;\n\n\treturn {\n\t\t...managerOptions,\n\t\tgatewayInformation: await manager.fetchGatewayInformation(),\n\t\tshardCount: await manager.getShardCount(),\n\t};\n}\n","import { setTimeout as sleep } from 'node:timers/promises';\nimport { AsyncQueue } from '@sapphire/async-queue';\nimport type { WebSocketManager } from '../ws/WebSocketManager.js';\n\nexport class IdentifyThrottler {\n\tprivate readonly queue = new AsyncQueue();\n\n\tprivate identifyState = {\n\t\tremaining: 0,\n\t\tresetsAt: Number.POSITIVE_INFINITY,\n\t};\n\n\tpublic constructor(private readonly manager: WebSocketManager) {}\n\n\tpublic async waitForIdentify(): Promise<void> {\n\t\tawait this.queue.wait();\n\n\t\ttry {\n\t\t\tif (this.identifyState.remaining <= 0) {\n\t\t\t\tconst diff = this.identifyState.resetsAt - Date.now();\n\t\t\t\tif (diff <= 5_000) {\n\t\t\t\t\t// To account for the latency the IDENTIFY payload goes through, we add a bit more wait time\n\t\t\t\t\tconst time = diff + Math.random() * 1_500;\n\t\t\t\t\tawait sleep(time);\n\t\t\t\t}\n\n\t\t\t\tconst info = await this.manager.fetchGatewayInformation();\n\t\t\t\tthis.identifyState = {\n\t\t\t\t\tremaining: info.session_start_limit.max_concurrency,\n\t\t\t\t\tresetsAt: Date.now() + 5_000,\n\t\t\t\t};\n\t\t\t}\n\n\t\t\tthis.identifyState.remaining--;\n\t\t} finally {\n\t\t\tthis.queue.shift();\n\t\t}\n\t}\n}\n","import { IdentifyThrottler } from '../../utils/IdentifyThrottler.js';\nimport type { SessionInfo, WebSocketManager } from '../../ws/WebSocketManager.js';\nimport type { FetchingStrategyOptions, IContextFetchingStrategy } from './IContextFetchingStrategy.js';\n\nexport class SimpleContextFetchingStrategy implements IContextFetchingStrategy {\n\t// This strategy assumes every shard is running under the same process - therefore we need a single\n\t// IdentifyThrottler per manager.\n\tprivate static throttlerCache = new WeakMap<WebSocketManager, IdentifyThrottler>();\n\n\tprivate static ensureThrottler(manager: WebSocketManager): IdentifyThrottler {\n\t\tconst existing = SimpleContextFetchingStrategy.throttlerCache.get(manager);\n\t\tif (existing) {\n\t\t\treturn existing;\n\t\t}\n\n\t\tconst throttler = new IdentifyThrottler(manager);\n\t\tSimpleContextFetchingStrategy.throttlerCache.set(manager, throttler);\n\t\treturn throttler;\n\t}\n\n\tprivate readonly throttler: IdentifyThrottler;\n\n\tpublic constructor(private readonly manager: WebSocketManager, public readonly options: FetchingStrategyOptions) {\n\t\tthis.throttler = SimpleContextFetchingStrategy.ensureThrottler(manager);\n\t}\n\n\tpublic async retrieveSessionInfo(shardId: number): Promise<SessionInfo | null> {\n\t\treturn this.manager.options.retrieveSessionInfo(shardId);\n\t}\n\n\tpublic updateSessionInfo(shardId: number, sessionInfo: SessionInfo | null) {\n\t\treturn this.manager.options.updateSessionInfo(shardId, sessionInfo);\n\t}\n\n\tpublic async waitForIdentify(): Promise<void> {\n\t\tawait this.throttler.waitForIdentify();\n\t}\n}\n","import { isMainThread, parentPort } from 'node:worker_threads';\nimport { Collection } from '@discordjs/collection';\nimport type { SessionInfo } from '../../ws/WebSocketManager.js';\nimport {\n\tWorkerRecievePayloadOp,\n\tWorkerSendPayloadOp,\n\ttype WorkerRecievePayload,\n\ttype WorkerSendPayload,\n} from '../sharding/WorkerShardingStrategy.js';\nimport type { FetchingStrategyOptions, IContextFetchingStrategy } from './IContextFetchingStrategy.js';\n\nexport class WorkerContextFetchingStrategy implements IContextFetchingStrategy {\n\tprivate readonly sessionPromises = new Collection<number, (session: SessionInfo | null) => void>();\n\n\tprivate readonly waitForIdentifyPromises = new Collection<number, () => void>();\n\n\tpublic constructor(public readonly options: FetchingStrategyOptions) {\n\t\tif (isMainThread) {\n\t\t\tthrow new Error('Cannot instantiate WorkerContextFetchingStrategy on the main thread');\n\t\t}\n\n\t\tparentPort!.on('message', (payload: WorkerSendPayload) => {\n\t\t\tif (payload.op === WorkerSendPayloadOp.SessionInfoResponse) {\n\t\t\t\tthis.sessionPromises.get(payload.nonce)?.(payload.session);\n\t\t\t\tthis.sessionPromises.delete(payload.nonce);\n\t\t\t}\n\n\t\t\tif (payload.op === WorkerSendPayloadOp.ShardCanIdentify) {\n\t\t\t\tthis.waitForIdentifyPromises.get(payload.nonce)?.();\n\t\t\t\tthis.waitForIdentifyPromises.delete(payload.nonce);\n\t\t\t}\n\t\t});\n\t}\n\n\tpublic async retrieveSessionInfo(shardId: number): Promise<SessionInfo | null> {\n\t\tconst nonce = Math.random();\n\t\tconst payload = {\n\t\t\top: WorkerRecievePayloadOp.RetrieveSessionInfo,\n\t\t\tshardId,\n\t\t\tnonce,\n\t\t} satisfies WorkerRecievePayload;\n\t\t// eslint-disable-next-line no-promise-executor-return\n\t\tconst promise = new Promise<SessionInfo | null>((resolve) => this.sessionPromises.set(nonce, resolve));\n\t\tparentPort!.postMessage(payload);\n\t\treturn promise;\n\t}\n\n\tpublic updateSessionInfo(shardId: number, sessionInfo: SessionInfo | null) {\n\t\tconst payload = {\n\t\t\top: WorkerRecievePayloadOp.UpdateSessionInfo,\n\t\t\tshardId,\n\t\t\tsession: sessionInfo,\n\t\t} satisfies WorkerRecievePayload;\n\t\tparentPort!.postMessage(payload);\n\t}\n\n\tpublic async waitForIdentify(): Promise<void> {\n\t\tconst nonce = Math.random();\n\t\tconst payload = {\n\t\t\top: WorkerRecievePayloadOp.WaitForIdentify,\n\t\t\tnonce,\n\t\t} satisfies WorkerRecievePayload;\n\t\t// eslint-disable-next-line no-promise-executor-return\n\t\tconst promise = new Promise<void>((resolve) => this.waitForIdentifyPromises.set(nonce, resolve));\n\t\tparentPort!.postMessage(payload);\n\t\treturn promise;\n\t}\n}\n","import { once } from 'node:events';\nimport { join } from 'node:path';\nimport { Worker } from 'node:worker_threads';\nimport { Collection } from '@discordjs/collection';\nimport type { GatewaySendPayload } from 'discord-api-types/v10';\nimport { IdentifyThrottler } from '../../utils/IdentifyThrottler.js';\nimport type { SessionInfo, WebSocketManager } from '../../ws/WebSocketManager';\nimport type { WebSocketShardDestroyOptions, WebSocketShardEvents } from '../../ws/WebSocketShard';\nimport { managerToFetchingStrategyOptions, type FetchingStrategyOptions } from '../context/IContextFetchingStrategy.js';\nimport type { IShardingStrategy } from './IShardingStrategy.js';\n\nexport interface WorkerData extends FetchingStrategyOptions {\n\tshardIds: number[];\n}\n\nexport enum WorkerSendPayloadOp {\n\tConnect,\n\tDestroy,\n\tSend,\n\tSessionInfoResponse,\n\tShardCanIdentify,\n}\n\nexport type WorkerSendPayload =\n\t| { nonce: number; op: WorkerSendPayloadOp.SessionInfoResponse; session: SessionInfo | null }\n\t| { nonce: number; op: WorkerSendPayloadOp.ShardCanIdentify }\n\t| { op: WorkerSendPayloadOp.Connect; shardId: number }\n\t| { op: WorkerSendPayloadOp.Destroy; options?: WebSocketShardDestroyOptions; shardId: number }\n\t| { op: WorkerSendPayloadOp.Send; payload: GatewaySendPayload; shardId: number };\n\nexport enum WorkerRecievePayloadOp {\n\tConnected,\n\tDestroyed,\n\tEvent,\n\tRetrieveSessionInfo,\n\tUpdateSessionInfo,\n\tWaitForIdentify,\n}\n\nexport type WorkerRecievePayload =\n\t// Can't seem to get a type-safe union based off of the event, so I'm sadly leaving data as any for now\n\t| { data: any; event: WebSocketShardEvents; op: WorkerRecievePayloadOp.Event; shardId: number }\n\t| { nonce: number; op: WorkerRecievePayloadOp.RetrieveSessionInfo; shardId: number }\n\t| { nonce: number; op: WorkerRecievePayloadOp.WaitForIdentify }\n\t| { op: WorkerRecievePayloadOp.Connected; shardId: number }\n\t| { op: WorkerRecievePayloadOp.Destroyed; shardId: number }\n\t| { op: WorkerRecievePayloadOp.UpdateSessionInfo; session: SessionInfo | null; shardId: number };\n\n/**\n * Options for a {@link WorkerShardingStrategy}\n */\nexport interface WorkerShardingStrategyOptions {\n\t/**\n\t * Dictates how many shards should be spawned per worker thread.\n\t */\n\tshardsPerWorker: number | 'all';\n}\n\n/**\n * Strategy used to spawn threads in worker_threads\n */\nexport class WorkerShardingStrategy implements IShardingStrategy {\n\tprivate readonly manager: WebSocketManager;\n\n\tprivate readonly options: WorkerShardingStrategyOptions;\n\n\t#workers: Worker[] = [];\n\n\treadonly #workerByShardId = new Collection<number, Worker>();\n\n\tprivate readonly connectPromises = new Collection<number, () => void>();\n\n\tprivate readonly destroyPromises = new Collection<number, () => void>();\n\n\tprivate readonly throttler: IdentifyThrottler;\n\n\tpublic constructor(manager: WebSocketManager, options: WorkerShardingStrategyOptions) {\n\t\tthis.manager = manager;\n\t\tthis.throttler = new IdentifyThrottler(manager);\n\t\tthis.options = options;\n\t}\n\n\t/**\n\t * {@inheritDoc IShardingStrategy.spawn}\n\t */\n\tpublic async spawn(shardIds: number[]) {\n\t\tconst shardsPerWorker = this.options.shardsPerWorker === 'all' ? shardIds.length : this.options.shardsPerWorker;\n\t\tconst strategyOptions = await managerToFetchingStrategyOptions(this.manager);\n\n\t\tlet shards = 0;\n\t\twhile (shards !== shardIds.length) {\n\t\t\tconst slice = shardIds.slice(shards, shardsPerWorker + shards);\n\t\t\tconst workerData: WorkerData = {\n\t\t\t\t...strategyOptions,\n\t\t\t\tshardIds: slice,\n\t\t\t};\n\n\t\t\tconst worker = new Worker(join(__dirname, 'worker.js'), { workerData });\n\t\t\tawait once(worker, 'online');\n\t\t\tworker\n\t\t\t\t.on('error', (err) => {\n\t\t\t\t\tthrow err;\n\t\t\t\t})\n\t\t\t\t.on('messageerror', (err) => {\n\t\t\t\t\tthrow err;\n\t\t\t\t})\n\t\t\t\t.on('message', async (payload: WorkerRecievePayload) => this.onMessage(worker, payload));\n\n\t\t\tthis.#workers.push(worker);\n\t\t\tfor (const shardId of slice) {\n\t\t\t\tthis.#workerByShardId.set(shardId, worker);\n\t\t\t}\n\n\t\t\tshards += slice.length;\n\t\t}\n\t}\n\n\t/**\n\t * {@inheritDoc IShardingStrategy.connect}\n\t */\n\tpublic async connect() {\n\t\tconst promises = [];\n\n\t\tfor (const [shardId, worker] of this.#workerByShardId.entries()) {\n\t\t\tconst payload = {\n\t\t\t\top: WorkerSendPayloadOp.Connect,\n\t\t\t\tshardId,\n\t\t\t} satisfies WorkerSendPayload;\n\n\t\t\t// eslint-disable-next-line no-promise-executor-return\n\t\t\tconst promise = new Promise<void>((resolve) => this.connectPromises.set(shardId, resolve));\n\t\t\tworker.postMessage(payload);\n\t\t\tpromises.push(promise);\n\t\t}\n\n\t\tawait Promise.all(promises);\n\t}\n\n\t/**\n\t * {@inheritDoc IShardingStrategy.destroy}\n\t */\n\tpublic async destroy(options: Omit<WebSocketShardDestroyOptions, 'recover'> = {}) {\n\t\tconst promises = [];\n\n\t\tfor (const [shardId, worker] of this.#workerByShardId.entries()) {\n\t\t\tconst payload = {\n\t\t\t\top: WorkerSendPayloadOp.Destroy,\n\t\t\t\tshardId,\n\t\t\t\toptions,\n\t\t\t} satisfies WorkerSendPayload;\n\n\t\t\tpromises.push(\n\t\t\t\t// eslint-disable-next-line no-promise-executor-return, promise/prefer-await-to-then\n\t\t\t\tnew Promise<void>((resolve) => this.destroyPromises.set(shardId, resolve)).then(async () => worker.terminate()),\n\t\t\t);\n\t\t\tworker.postMessage(payload);\n\t\t}\n\n\t\tthis.#workers = [];\n\t\tthis.#workerByShardId.clear();\n\n\t\tawait Promise.all(promises);\n\t}\n\n\t/**\n\t * {@inheritDoc IShardingStrategy.send}\n\t */\n\tpublic send(shardId: number, data: GatewaySendPayload) {\n\t\tconst worker = this.#workerByShardId.get(shardId);\n\t\tif (!worker) {\n\t\t\tthrow new Error(`No worker found for shard ${shardId}`);\n\t\t}\n\n\t\tconst payload = {\n\t\t\top: WorkerSendPayloadOp.Send,\n\t\t\tshardId,\n\t\t\tpayload: data,\n\t\t} satisfies WorkerSendPayload;\n\t\tworker.postMessage(payload);\n\t}\n\n\tprivate async onMessage(worker: Worker, payload: WorkerRecievePayload) {\n\t\tswitch (payload.op) {\n\t\t\tcase WorkerRecievePayloadOp.Connected: {\n\t\t\t\tconst resolve = this.connectPromises.get(payload.shardId)!;\n\t\t\t\tresolve();\n\t\t\t\tthis.connectPromises.delete(payload.shardId);\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tcase WorkerRecievePayloadOp.Destroyed: {\n\t\t\t\tconst resolve = this.destroyPromises.get(payload.shardId)!;\n\t\t\t\tresolve();\n\t\t\t\tthis.destroyPromises.delete(payload.shardId);\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tcase WorkerRecievePayloadOp.Event: {\n\t\t\t\tthis.manager.emit(payload.event, { ...payload.data, shardId: payload.shardId });\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tcase WorkerRecievePayloadOp.RetrieveSessionInfo: {\n\t\t\t\tconst session = await this.manager.options.retrieveSessionInfo(payload.shardId);\n\t\t\t\tconst response: WorkerSendPayload = {\n\t\t\t\t\top: WorkerSendPayloadOp.SessionInfoResponse,\n\t\t\t\t\tnonce: payload.nonce,\n\t\t\t\t\tsession,\n\t\t\t\t};\n\t\t\t\tworker.postMessage(response);\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tcase WorkerRecievePayloadOp.UpdateSessionInfo: {\n\t\t\t\tawait this.manager.options.updateSessionInfo(payload.shardId, payload.session);\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tcase WorkerRecievePayloadOp.WaitForIdentify: {\n\t\t\t\tawait this.throttler.waitForIdentify();\n\t\t\t\tconst response: WorkerSendPayload = {\n\t\t\t\t\top: WorkerSendPayloadOp.ShardCanIdentify,\n\t\t\t\t\tnonce: payload.nonce,\n\t\t\t\t};\n\t\t\t\tworker.postMessage(response);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n}\n","import { Collection } from '@discordjs/collection';\nimport type { GatewaySendPayload } from 'discord-api-types/v10';\nimport type { WebSocketManager } from '../../ws/WebSocketManager';\nimport { WebSocketShard, WebSocketShardEvents, type WebSocketShardDestroyOptions } from '../../ws/WebSocketShard.js';\nimport { managerToFetchingStrategyOptions } from '../context/IContextFetchingStrategy.js';\nimport { SimpleContextFetchingStrategy } from '../context/SimpleContextFetchingStrategy.js';\nimport type { IShardingStrategy } from './IShardingStrategy.js';\n\n/**\n * Simple strategy that just spawns shards in the current process\n */\nexport class SimpleShardingStrategy implements IShardingStrategy {\n\tprivate readonly manager: WebSocketManager;\n\n\tprivate readonly shards = new Collection<number, WebSocketShard>();\n\n\tpublic constructor(manager: WebSocketManager) {\n\t\tthis.manager = manager;\n\t}\n\n\t/**\n\t * {@inheritDoc IShardingStrategy.spawn}\n\t */\n\tpublic async spawn(shardIds: number[]) {\n\t\tconst strategyOptions = await managerToFetchingStrategyOptions(this.manager);\n\t\tfor (const shardId of shardIds) {\n\t\t\tconst strategy = new SimpleContextFetchingStrategy(this.manager, strategyOptions);\n\t\t\tconst shard = new WebSocketShard(strategy, shardId);\n\t\t\tfor (const event of Object.values(WebSocketShardEvents)) {\n\t\t\t\t// @ts-expect-error: Intentional\n\t\t\t\tshard.on(event, (payload) => this.manager.emit(event, { ...payload, shardId }));\n\t\t\t}\n\n\t\t\tthis.shards.set(shardId, shard);\n\t\t}\n\t}\n\n\t/**\n\t * {@inheritDoc IShardingStrategy.connect}\n\t */\n\tpublic async connect() {\n\t\tconst promises = [];\n\n\t\tfor (const shard of this.shards.values()) {\n\t\t\tpromises.push(shard.connect());\n\t\t}\n\n\t\tawait Promise.all(promises);\n\t}\n\n\t/**\n\t * {@inheritDoc IShardingStrategy.destroy}\n\t */\n\tpublic async destroy(options?: Omit<WebSocketShardDestroyOptions, 'recover'>) {\n\t\tconst promises = [];\n\n\t\tfor (const shard of this.shards.values()) {\n\t\t\tpromises.push(shard.destroy(options));\n\t\t}\n\n\t\tawait Promise.all(promises);\n\t\tthis.shards.clear();\n\t}\n\n\t/**\n\t * {@inheritDoc IShardingStrategy.send}\n\t */\n\tpublic async send(shardId: number, payload: GatewaySendPayload) {\n\t\tconst shard = this.shards.get(shardId);\n\t\tif (!shard) throw new Error(`Shard ${shardId} not found`);\n\t\treturn shard.send(payload);\n\t}\n}\n","/* eslint-disable id-length */\nimport { Buffer } from 'node:buffer';\nimport { once } from 'node:events';\nimport { setTimeout, clearInterval, clearTimeout, setInterval } from 'node:timers';\nimport { setTimeout as sleep } from 'node:timers/promises';\nimport { URLSearchParams } from 'node:url';\nimport { TextDecoder } from 'node:util';\nimport { inflate } from 'node:zlib';\nimport { Collection } from '@discordjs/collection';\nimport { lazy } from '@discordjs/util';\nimport { AsyncQueue } from '@sapphire/async-queue';\nimport { AsyncEventEmitter } from '@vladfrangu/async_event_emitter';\nimport {\n\tGatewayCloseCodes,\n\tGatewayDispatchEvents,\n\tGatewayOpcodes,\n\ttype GatewayDispatchPayload,\n\ttype GatewayIdentifyData,\n\ttype GatewayReceivePayload,\n\ttype GatewaySendPayload,\n\ttype GatewayReadyDispatchData,\n} from 'discord-api-types/v10';\nimport { WebSocket, type RawData } from 'ws';\nimport type { Inflate } from 'zlib-sync';\nimport type { IContextFetchingStrategy } from '../strategies/context/IContextFetchingStrategy';\nimport { getInitialSendRateLimitState, ImportantGatewayOpcodes } from '../utils/constants.js';\nimport type { SessionInfo } from './WebSocketManager.js';\n\n// eslint-disable-next-line promise/prefer-await-to-then\nconst getZlibSync = lazy(async () => import('zlib-sync').then((mod) => mod.default).catch(() => null));\n\nexport enum WebSocketShardEvents {\n\tClosed = 'closed',\n\tDebug = 'debug',\n\tDispatch = 'dispatch',\n\tHello = 'hello',\n\tReady = 'ready',\n\tResumed = 'resumed',\n}\n\nexport enum WebSocketShardStatus {\n\tIdle,\n\tConnecting,\n\tResuming,\n\tReady,\n}\n\nexport enum WebSocketShardDestroyRecovery {\n\tReconnect,\n\tResume,\n}\n\n// eslint-disable-next-line @typescript-eslint/consistent-type-definitions\nexport type WebSocketShardEventsMap = {\n\t[WebSocketShardEvents.Closed]: [{ code: number }];\n\t[WebSocketShardEvents.Debug]: [payload: { message: string }];\n\t[WebSocketShardEvents.Hello]: [];\n\t[WebSocketShardEvents.Ready]: [payload: { data: GatewayReadyDispatchData }];\n\t[WebSocketShardEvents.Resumed]: [];\n\t[WebSocketShardEvents.Dispatch]: [payload: { data: GatewayDispatchPayload }];\n};\n\nexport interface WebSocketShardDestroyOptions {\n\tcode?: number;\n\treason?: string;\n\trecover?: WebSocketShardDestroyRecovery;\n}\n\nexport enum CloseCodes {\n\tNormal = 1_000,\n\tResuming = 4_200,\n}\n\nexport interface SendRateLimitState {\n\tremaining: number;\n\tresetAt: number;\n}\n\nexport class WebSocketShard extends AsyncEventEmitter<WebSocketShardEventsMap> {\n\tprivate connection: WebSocket | null = null;\n\n\tprivate readonly id: number;\n\n\tprivate useIdentifyCompress = false;\n\n\tprivate inflate: Inflate | null = null;\n\n\tprivate readonly textDecoder = new TextDecoder();\n\n\tprivate status: WebSocketShardStatus = WebSocketShardStatus.Idle;\n\n\tprivate replayedEvents = 0;\n\n\tprivate isAck = true;\n\n\tprivate sendRateLimitState: SendRateLimitState = getInitialSendRateLimitState();\n\n\tprivate heartbeatInterval: NodeJS.Timer | null = null;\n\n\tprivate lastHeartbeatAt = -1;\n\n\tprivate session: SessionInfo | null = null;\n\n\tprivate readonly sendQueue = new AsyncQueue();\n\n\tprivate readonly timeouts = new Collection<WebSocketShardEvents, NodeJS.Timeout>();\n\n\tpublic readonly strategy: IContextFetchingStrategy;\n\n\tpublic constructor(strategy: IContextFetchingStrategy, id: number) {\n\t\tsuper();\n\t\tthis.strategy = strategy;\n\t\tthis.id = id;\n\t}\n\n\tpublic async connect() {\n\t\tif (this.status !== WebSocketShardStatus.Idle) {\n\t\t\tthrow new Error(\"Tried to connect a shard that wasn't idle\");\n\t\t}\n\n\t\tconst { version, encoding, compression } = this.strategy.options;\n\t\tconst params = new URLSearchParams({ v: version, encoding });\n\t\tif (compression) {\n\t\t\tconst zlib = await getZlibSync();\n\t\t\tif (zlib) {\n\t\t\t\tparams.append('compress', compression);\n\t\t\t\tthis.inflate = new zlib.Inflate({\n\t\t\t\t\tchunkSize: 65_535,\n\t\t\t\t\tto: 'string',\n\t\t\t\t});\n\t\t\t} else if (!this.useIdentifyCompress) {\n\t\t\t\tthis.useIdentifyCompress = true;\n\t\t\t\tconsole.warn(\n\t\t\t\t\t'WebSocketShard: Compression is enabled but zlib-sync is not installed, falling back to identify compress',\n\t\t\t\t);\n\t\t\t}\n\t\t}\n\n\t\tconst session = this.session ?? (await this.strategy.retrieveSessionInfo(this.id));\n\n\t\tconst url = `${session?.resumeURL ?? this.strategy.options.gatewayInformation.url}?${params.toString()}`;\n\t\tthis.debug([`Connecting to ${url}`]);\n\t\tconst connection = new WebSocket(url, { handshakeTimeout: this.strategy.options.handshakeTimeout ?? undefined })\n\t\t\t.on('message', this.onMessage.bind(this))\n\t\t\t.on('error', this.onError.bind(this))\n\t\t\t.on('close', this.onClose.bind(this));\n\n\t\tconnection.binaryType = 'arraybuffer';\n\t\tthis.connection = connection;\n\n\t\tthis.status = WebSocketShardStatus.Connecting;\n\n\t\tthis.sendRateLimitState = getInitialSendRateLimitState();\n\n\t\tawait this.waitForEvent(WebSocketShardEvents.Hello, this.strategy.options.helloTimeout);\n\n\t\tif (session?.shardCount === this.strategy.options.shardCount) {\n\t\t\tthis.session = session;\n\t\t\tawait this.resume(session);\n\t\t} else {\n\t\t\tawait this.identify();\n\t\t}\n\t}\n\n\tpublic async destroy(options: WebSocketShardDestroyOptions = {}) {\n\t\tif (this.status === WebSocketShardStatus.Idle) {\n\t\t\tthis.debug(['Tried to destroy a shard that was idle']);\n\t\t\treturn;\n\t\t}\n\n\t\tif (!options.code) {\n\t\t\toptions.code = options.recover === WebSocketShardDestroyRecovery.Resume ? CloseCodes.Resuming : CloseCodes.Normal;\n\t\t}\n\n\t\tthis.debug([\n\t\t\t'Destroying shard',\n\t\t\t`Reason: ${options.reason ?? 'none'}`,\n\t\t\t`Code: ${options.code}`,\n\t\t\t`Recover: ${options.recover === undefined ? 'none' : WebSocketShardDestroyRecovery[options.recover]!}`,\n\t\t]);\n\n\t\t// Reset state\n\t\tthis.isAck = true;\n\t\tif (this.heartbeatInterval) {\n\t\t\tclearInterval(this.heartbeatInterval);\n\t\t}\n\n\t\tthis.lastHeartbeatAt = -1;\n\n\t\t// Clear session state if applicable\n\t\tif (options.recover !== WebSocketShardDestroyRecovery.Resume && this.session) {\n\t\t\tthis.session = null;\n\t\t\tawait this.strategy.updateSessionInfo(this.id, null);\n\t\t}\n\n\t\tif (this.connection) {\n\t\t\t// No longer need to listen to messages\n\t\t\tthis.connection.removeAllListeners('message');\n\t\t\t// Prevent a reconnection loop by unbinding the main close event\n\t\t\tthis.connection.removeAllListeners('close');\n\n\t\t\tconst shouldClose =\n\t\t\t\tthis.connection.readyState === WebSocket.OPEN || this.connection.readyState === WebSocket.CONNECTING;\n\n\t\t\tthis.debug([\n\t\t\t\t'Connection status during destroy',\n\t\t\t\t`Needs closing: ${shouldClose}`,\n\t\t\t\t`Ready state: ${this.connection.readyState}`,\n\t\t\t]);\n\n\t\t\tif (shouldClose) {\n\t\t\t\tthis.connection.close(options.code, options.reason);\n\t\t\t\tawait once(this.connection, 'close');\n\t\t\t\tthis.emit(WebSocketShardEvents.Closed, { code: options.code });\n\t\t\t}\n\n\t\t\t// Lastly, remove the error event.\n\t\t\t// Doing this earlier would cause a hard crash in case an error event fired on our `close` call\n\t\t\tthis.connection.removeAllListeners('error');\n\t\t} else {\n\t\t\tthis.debug(['Destroying a shard that has no connection; please open an issue on GitHub']);\n\t\t}\n\n\t\tthis.status = WebSocketShardStatus.Idle;\n\n\t\tif (options.recover !== undefined) {\n\t\t\treturn this.connect();\n\t\t}\n\t}\n\n\tprivate async waitForEvent(event: WebSocketShardEvents, timeoutDuration?: number | null) {\n\t\tthis.debug([`Waiting for event ${event} for ${timeoutDuration ? `${timeoutDuration}ms` : 'indefinitely'}`]);\n\t\tconst controller = new AbortController();\n\t\tconst timeout = timeoutDuration ? setTimeout(() => controller.abort(), timeoutDuration).unref() : null;\n\t\tif (timeout) {\n\t\t\tthis.timeouts.set(event, timeout);\n\t\t}\n\n\t\tawait once(this, event, { signal: controller.signal });\n\t\tif (timeout) {\n\t\t\tclearTimeout(timeout);\n\t\t\tthis.timeouts.delete(event);\n\t\t}\n\t}\n\n\tpublic async send(payload: GatewaySendPayload): Promise<void> {\n\t\tif (!this.connection) {\n\t\t\tthrow new Error(\"WebSocketShard wasn't connected\");\n\t\t}\n\n\t\tif (this.status !== WebSocketShardStatus.Ready && !ImportantGatewayOpcodes.has(payload.op)) {\n\t\t\tthis.debug(['Tried to send a non-crucial payload before the shard was ready, waiting']);\n\t\t\tawait once(this, WebSocketShardEvents.Ready);\n\t\t}\n\n\t\tawait this.sendQueue.wait();\n\n\t\tif (--this.sendRateLimitState.remaining <= 0) {\n\t\t\tconst now = Date.now();\n\n\t\t\tif (this.sendRateLimitState.resetAt > now) {\n\t\t\t\tconst sleepFor = this.sendRateLimitState.resetAt - now;\n\n\t\t\t\tthis.debug([`Was about to hit the send rate limit, sleeping for ${sleepFor}ms`]);\n\t\t\t\tconst controller = new AbortController();\n\n\t\t\t\t// Sleep for the remaining time, but if the connection closes in the meantime, we shouldn't wait the remainder to avoid blocking the new conn\n\t\t\t\tconst interrupted = await Promise.race([\n\t\t\t\t\tsleep(sleepFor).then(() => false),\n\t\t\t\t\tonce(this, WebSocketShardEvents.Closed, { signal: controller.signal }).then(() => true),\n\t\t\t\t]);\n\n\t\t\t\tif (interrupted) {\n\t\t\t\t\tthis.debug(['Connection closed while waiting for the send rate limit to reset, re-queueing payload']);\n\t\t\t\t\tthis.sendQueue.shift();\n\t\t\t\t\treturn this.send(payload);\n\t\t\t\t}\n\n\t\t\t\t// This is so the listener from the `once` call is removed\n\t\t\t\tcontroller.abort();\n\t\t\t}\n\n\t\t\tthis.sendRateLimitState = getInitialSendRateLimitState();\n\t\t}\n\n\t\tthis.sendQueue.shift();\n\t\tthis.connection.send(JSON.stringify(payload));\n\t}\n\n\tprivate async identify() {\n\t\tthis.debug([\n\t\t\t'Identifying',\n\t\t\t`shard id: ${this.id.toString()}`,\n\t\t\t`shard count: ${this.strategy.options.shardCount}`,\n\t\t\t`intents: ${this.strategy.options.intents}`,\n\t\t\t`compression: ${this.inflate ? 'zlib-stream' : this.useIdentifyCompress ? 'identify' : 'none'}`,\n\t\t]);\n\n\t\tawait this.strategy.waitForIdentify();\n\n\t\tconst d: GatewayIdentifyData = {\n\t\t\ttoken: this.strategy.options.token,\n\t\t\tproperties: this.strategy.options.identifyProperties,\n\t\t\tintents: this.strategy.options.intents,\n\t\t\tcompress: this.useIdentifyCompress,\n\t\t\tshard: [this.id, this.strategy.options.shardCount],\n\t\t};\n\n\t\tif (this.strategy.options.largeThreshold) {\n\t\t\td.large_threshold = this.strategy.options.largeThreshold;\n\t\t}\n\n\t\tif (this.strategy.options.initialPresence) {\n\t\t\td.presence = this.strategy.options.initialPresence;\n\t\t}\n\n\t\tawait this.send({\n\t\t\top: GatewayOpcodes.Identify,\n\t\t\td,\n\t\t});\n\n\t\tawait this.waitForEvent(WebSocketShardEvents.Ready, this.strategy.options.readyTimeout);\n\t\tthis.status = WebSocketShardStatus.Ready;\n\t}\n\n\tprivate async resume(session: SessionInfo) {\n\t\tthis.debug(['Resuming session']);\n\t\tthis.status = WebSocketShardStatus.Resuming;\n\t\tthis.replayedEvents = 0;\n\t\treturn this.send({\n\t\t\top: GatewayOpcodes.Resume,\n\t\t\td: {\n\t\t\t\ttoken: this.strategy.options.token,\n\t\t\t\tseq: session.sequence,\n\t\t\t\tsession_id: session.sessionId,\n\t\t\t},\n\t\t});\n\t}\n\n\tprivate async heartbeat(requested = false) {\n\t\tif (!this.isAck && !requested) {\n\t\t\treturn this.destroy({ reason: 'Zombie connection', recover: WebSocketShardDestroyRecovery.Resume });\n\t\t}\n\n\t\tawait this.send({\n\t\t\top: GatewayOpcodes.Heartbeat,\n\t\t\td: this.session?.sequence ?? null,\n\t\t});\n\n\t\tthis.lastHeartbeatAt = Date.now();\n\t\tthis.isAck = false;\n\t}\n\n\tprivate async unpackMessage(data: ArrayBuffer | Buffer, isBinary: boolean): Promise<GatewayReceivePayload | null> {\n\t\tconst decompressable = new Uint8Array(data);\n\n\t\t// Deal with no compression\n\t\tif (!isBinary) {\n\t\t\treturn JSON.parse(this.textDecoder.decode(decompressable)) as GatewayReceivePayload;\n\t\t}\n\n\t\t// Deal with identify compress\n\t\tif (this.useIdentifyCompress) {\n\t\t\treturn new Promise((resolve, reject) => {\n\t\t\t\tinflate(decompressable, { chunkSize: 65_535 }, (err, result) => {\n\t\t\t\t\tif (err) {\n\t\t\t\t\t\treject(err);\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\n\t\t\t\t\tresolve(JSON.parse(this.textDecoder.decode(result)) as GatewayReceivePayload);\n\t\t\t\t});\n\t\t\t});\n\t\t}\n\n\t\t// Deal with gw wide zlib-stream compression\n\t\tif (this.inflate) {\n\t\t\tconst l = decompressable.length;\n\t\t\tconst flush =\n\t\t\t\tl >= 4 &&\n\t\t\t\tdecompressable[l - 4] === 0x00 &&\n\t\t\t\tdecompressable[l - 3] === 0x00 &&\n\t\t\t\tdecompressable[l - 2] === 0xff &&\n\t\t\t\tdecompressable[l - 1] === 0xff;\n\n\t\t\tconst zlib = (await getZlibSync())!;\n\t\t\tthis.inflate.push(Buffer.from(decompressable), flush ? zlib.Z_SYNC_FLUSH : zlib.Z_NO_FLUSH);\n\n\t\t\tif (this.inflate.err) {\n\t\t\t\tthis.emit('error', `${this.inflate.err}${this.inflate.msg ? `: ${this.inflate.msg}` : ''}`);\n\t\t\t}\n\n\t\t\tif (!flush) {\n\t\t\t\treturn null;\n\t\t\t}\n\n\t\t\tconst { result } = this.inflate;\n\t\t\tif (!result) {\n\t\t\t\treturn null;\n\t\t\t}\n\n\t\t\treturn JSON.parse(typeof result === 'string' ? result : this.textDecoder.decode(result)) as GatewayReceivePayload;\n\t\t}\n\n\t\tthis.debug([\n\t\t\t'Received a message we were unable to decompress',\n\t\t\t`isBinary: ${isBinary.toString()}`,\n\t\t\t`useIdentifyCompress: ${this.useIdentifyCompress.toString()}`,\n\t\t\t`inflate: ${Boolean(this.inflate).toString()}`,\n\t\t]);\n\n\t\treturn null;\n\t}\n\n\tprivate async onMessage(data: RawData, isBinary: boolean) {\n\t\tconst payload = await this.unpackMessage(data as ArrayBuffer | Buffer, isBinary);\n\t\tif (!payload) {\n\t\t\treturn;\n\t\t}\n\n\t\tswitch (payload.op) {\n\t\t\tcase GatewayOpcodes.Dispatch: {\n\t\t\t\tif (this.status === WebSocketShardStatus.Resuming) {\n\t\t\t\t\tthis.replayedEvents++;\n\t\t\t\t}\n\n\t\t\t\t// eslint-disable-next-line sonarjs/no-nested-switch\n\t\t\t\tswitch (payload.t) {\n\t\t\t\t\tcase GatewayDispatchEvents.Ready: {\n\t\t\t\t\t\tthis.emit(WebSocketShardEvents.Ready, { data: payload.d });\n\n\t\t\t\t\t\tthis.session ??= {\n\t\t\t\t\t\t\tsequence: payload.s,\n\t\t\t\t\t\t\tsessionId: payload.d.session_id,\n\t\t\t\t\t\t\tshardId: this.id,\n\t\t\t\t\t\t\tshardCount: this.strategy.options.shardCount,\n\t\t\t\t\t\t\tresumeURL: payload.d.resume_gateway_url,\n\t\t\t\t\t\t};\n\n\t\t\t\t\t\tawait this.strategy.updateSessionInfo(this.id, this.session);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\n\t\t\t\t\tcase GatewayDispatchEvents.Resumed: {\n\t\t\t\t\t\tthis.status = WebSocketShardStatus.Ready;\n\t\t\t\t\t\tthis.debug([`Resumed and replayed ${this.replayedEvents} events`]);\n\t\t\t\t\t\tthis.emit(WebSocketShardEvents.Resumed);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\n\t\t\t\t\tdefault: {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (this.session && payload.s > this.session.sequence) {\n\t\t\t\t\tthis.session.sequence = payload.s;\n\t\t\t\t\tawait this.strategy.updateSessionInfo(this.id, this.session);\n\t\t\t\t}\n\n\t\t\t\tthis.emit(WebSocketShardEvents.Dispatch, { data: payload });\n\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tcase GatewayOpcodes.Heartbeat: {\n\t\t\t\tawait this.heartbeat(true);\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tcase GatewayOpcodes.Reconnect: {\n\t\t\t\tawait this.destroy({\n\t\t\t\t\treason: 'Told to reconnect by Discord',\n\t\t\t\t\trecover: WebSocketShardDestroyRecovery.Resume,\n\t\t\t\t});\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tcase GatewayOpcodes.InvalidSession: {\n\t\t\t\tconst readyTimeout = this.timeouts.get(WebSocketShardEvents.Ready);\n\t\t\t\treadyTimeout?.refresh();\n\t\t\t\tthis.debug([`Invalid session; will attempt to resume: ${payload.d.toString()}`]);\n\t\t\t\tconst session = this.session ?? (await this.strategy.retrieveSessionInfo(this.id));\n\t\t\t\tif (payload.d && session) {\n\t\t\t\t\tawait this.resume(session);\n\t\t\t\t} else {\n\t\t\t\t\tawait this.destroy({\n\t\t\t\t\t\treason: 'Invalid session',\n\t\t\t\t\t\trecover: WebSocketShardDestroyRecovery.Reconnect,\n\t\t\t\t\t});\n\t\t\t\t}\n\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tcase GatewayOpcodes.Hello: {\n\t\t\t\tthis.emit(WebSocketShardEvents.Hello);\n\t\t\t\tthis.debug([`Starting to heartbeat every ${payload.d.heartbeat_interval}ms`]);\n\t\t\t\tthis.heartbeatInterval = setInterval(() => void this.heartbeat(), payload.d.heartbeat_interval);\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tcase GatewayOpcodes.HeartbeatAck: {\n\t\t\t\tthis.isAck = true;\n\t\t\t\tthis.debug([`Got heartbeat ack after ${Date.now() - this.lastHeartbeatAt}ms`]);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate onError(err: Error) {\n\t\tthis.emit('error', err);\n\t}\n\n\tprivate async onClose(code: number) {\n\t\tthis.emit(WebSocketShardEvents.Closed, { code });\n\n\t\tswitch (code) {\n\t\t\tcase CloseCodes.Normal: {\n\t\t\t\treturn this.destroy({\n\t\t\t\t\tcode,\n\t\t\t\t\treason: 'Got disconnected by Discord',\n\t\t\t\t\trecover: WebSocketShardDestroyRecovery.Reconnect,\n\t\t\t\t});\n\t\t\t}\n\n\t\t\tcase CloseCodes.Resuming: {\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tcase GatewayCloseCodes.UnknownError: {\n\t\t\t\tthis.debug([`An unknown error occured: ${code}`]);\n\t\t\t\treturn this.destroy({ code, recover: WebSocketShardDestroyRecovery.Resume });\n\t\t\t}\n\n\t\t\tcase GatewayCloseCodes.UnknownOpcode: {\n\t\t\t\tthis.debug(['An invalid opcode was sent to Discord.']);\n\t\t\t\treturn this.destroy({ code, recover: WebSocketShardDestroyRecovery.Resume });\n\t\t\t}\n\n\t\t\tcase GatewayCloseCodes.DecodeError: {\n\t\t\t\tthis.debug(['An invalid payload was sent to Discord.']);\n\t\t\t\treturn this.destroy({ code, recover: WebSocketShardDestroyRecovery.Resume });\n\t\t\t}\n\n\t\t\tcase GatewayCloseCodes.NotAuthenticated: {\n\t\t\t\tthis.debug(['A request was somehow sent before the identify/resume payload.']);\n\t\t\t\treturn this.destroy({ code, recover: WebSocketShardDestroyRecovery.Reconnect });\n\t\t\t}\n\n\t\t\tcase GatewayCloseCodes.AuthenticationFailed: {\n\t\t\t\tthrow new Error('Authentication failed');\n\t\t\t}\n\n\t\t\tcase GatewayCloseCodes.AlreadyAuthenticated: {\n\t\t\t\tthis.debug(['More than one auth payload was sent.']);\n\t\t\t\treturn this.destroy({ code, recover: WebSocketShardDestroyRecovery.Reconnect });\n\t\t\t}\n\n\t\t\tcase GatewayCloseCodes.InvalidSeq: {\n\t\t\t\tthis.debug(['An invalid sequence was sent.']);\n\t\t\t\treturn this.destroy({ code, recover: WebSocketShardDestroyRecovery.Reconnect });\n\t\t\t}\n\n\t\t\tcase GatewayCloseCodes.RateLimited: {\n\t\t\t\tthis.debug(['The WebSocket rate limit has been hit, this should never happen']);\n\t\t\t\treturn this.destroy({ code, recover: WebSocketShardDestroyRecovery.Reconnect });\n\t\t\t}\n\n\t\t\tcase GatewayCloseCodes.SessionTimedOut: {\n\t\t\t\tthis.debug(['Session timed out.']);\n\t\t\t\treturn this.destroy({ code, recover: WebSocketShardDestroyRecovery.Resume });\n\t\t\t}\n\n\t\t\tcase GatewayCloseCodes.InvalidShard: {\n\t\t\t\tthrow new Error('Invalid shard');\n\t\t\t}\n\n\t\t\tcase GatewayCloseCodes.ShardingRequired: {\n\t\t\t\tthrow new Error('Sharding is required');\n\t\t\t}\n\n\t\t\tcase GatewayCloseCodes.InvalidAPIVersion: {\n\t\t\t\tthrow new Error('Used an invalid API version');\n\t\t\t}\n\n\t\t\tcase GatewayCloseCodes.InvalidIntents: {\n\t\t\t\tthrow new Error('Used invalid intents');\n\t\t\t}\n\n\t\t\tcase GatewayCloseCodes.DisallowedIntents: {\n\t\t\t\tthrow new Error('Used disallowed intents');\n\t\t\t}\n\n\t\t\tdefault: {\n\t\t\t\tthis.debug([`The gateway closed with an unexpected code ${code}, attempting to resume.`]);\n\t\t\t\treturn this.destroy({ code, recover: WebSocketShardDestroyRecovery.Resume });\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate debug(messages: [string, ...string[]]) {\n\t\tconst message = `${messages[0]}${\n\t\t\tmessages.length > 1\n\t\t\t\t? `\\n${messages\n\t\t\t\t\t\t.slice(1)\n\t\t\t\t\t\t.map((m) => `\t${m}`)\n\t\t\t\t\t\t.join('\\n')}`\n\t\t\t\t: ''\n\t\t}`;\n\n\t\tthis.emit(WebSocketShardEvents.Debug, { message });\n\t}\n}\n","import process from 'node:process';\nimport { Collection } from '@discordjs/collection';\nimport { lazy } from '@discordjs/util';\nimport { APIVersion, GatewayOpcodes } from 'discord-api-types/v10';\nimport type { SessionInfo, OptionalWebSocketManagerOptions } from '../ws/WebSocketManager.js';\nimport type { SendRateLimitState } from '../ws/WebSocketShard.js';\n\n/**\n * Valid encoding types\n */\nexport enum Encoding {\n\tJSON = 'json',\n}\n\n/**\n * Valid compression methods\n */\nexport enum CompressionMethod {\n\tZlibStream = 'zlib-stream',\n}\n\nexport const DefaultDeviceProperty = `@discordjs/ws 0.6.0`;\n\nconst getDefaultSessionStore = lazy(() => new Collection<number, SessionInfo | null>());\n\n/**\n * Default options used by the manager\n */\nexport const DefaultWebSocketManagerOptions = {\n\tshardCount: null,\n\tshardIds: null,\n\tlargeThreshold: null,\n\tinitialPresence: null,\n\tidentifyProperties: {\n\t\tbrowser: DefaultDeviceProperty,\n\t\tdevice: DefaultDeviceProperty,\n\t\tos: process.platform,\n\t},\n\tversion: APIVersion,\n\tencoding: Encoding.JSON,\n\tcompression: null,\n\tretrieveSessionInfo(shardId) {\n\t\tconst store = getDefaultSessionStore();\n\t\treturn store.get(shardId) ?? null;\n\t},\n\tupdateSessionInfo(shardId: number, info: SessionInfo | null) {\n\t\tconst store = getDefaultSessionStore();\n\t\tif (info) {\n\t\t\tstore.set(shardId, info);\n\t\t} else {\n\t\t\tstore.delete(shardId);\n\t\t}\n\t},\n\thandshakeTimeout: 30_000,\n\thelloTimeout: 60_000,\n\treadyTimeout: 15_000,\n} as const satisfies OptionalWebSocketManagerOptions;\n\nexport const ImportantGatewayOpcodes = new Set([\n\tGatewayOpcodes.Heartbeat,\n\tGatewayOpcodes.Identify,\n\tGatewayOpcodes.Resume,\n]);\n\nexport function getInitialSendRateLimitState(): SendRateLimitState {\n\treturn {\n\t\tremaining: 120,\n\t\tresetAt: Date.now() + 60_000,\n\t};\n}\n","import type { REST } from '@discordjs/rest';\nimport { range, type Awaitable } from '@discordjs/util';\nimport { AsyncEventEmitter } from '@vladfrangu/async_event_emitter';\nimport {\n\tRoutes,\n\ttype APIGatewayBotInfo,\n\ttype GatewayIdentifyProperties,\n\ttype GatewayPresenceUpdateData,\n\ttype RESTGetAPIGatewayBotResult,\n\ttype GatewayIntentBits,\n\ttype GatewaySendPayload,\n} from 'discord-api-types/v10';\nimport type { IShardingStrategy } from '../strategies/sharding/IShardingStrategy';\nimport { SimpleShardingStrategy } from '../strategies/sharding/SimpleShardingStrategy.js';\nimport { DefaultWebSocketManagerOptions, type CompressionMethod, type Encoding } from '../utils/constants.js';\nimport type { WebSocketShardDestroyOptions, WebSocketShardEventsMap } from './WebSocketShard.js';\n\n/**\n * Represents a range of shard ids\n */\nexport interface ShardRange {\n\tend: number;\n\tstart: number;\n}\n\n/**\n * Session information for a given shard, used to resume a session\n */\nexport interface SessionInfo {\n\t/**\n\t * URL to use when resuming\n\t */\n\tresumeURL: string;\n\t/**\n\t * The sequence number of the last message sent by the shard\n\t */\n\tsequence: number;\n\t/**\n\t * Session id for this shard\n\t */\n\tsessionId: string;\n\t/**\n\t * The total number of shards at the time of this shard identifying\n\t */\n\tshardCount: number;\n\t/**\n\t * The id of the shard\n\t */\n\tshardId: number;\n}\n\n/**\n * Required options for the WebSocketManager\n */\nexport interface RequiredWebSocketManagerOptions {\n\t/**\n\t * The intents to request\n\t */\n\tintents: GatewayIntentBits;\n\t/**\n\t * The REST instance to use for fetching gateway information\n\t */\n\trest: REST;\n\t/**\n\t * The token to use for identifying with the gateway\n\t */\n\ttoken: string;\n}\n\n/**\n * Optional additional configuration for the WebSocketManager\n */\nexport interface OptionalWebSocketManagerOptions {\n\t/**\n\t * The compression method to use\n\t *\n\t * @defaultValue `null` (no compression)\n\t */\n\tcompression: CompressionMethod | null;\n\t/**\n\t * The encoding to use\n\t *\n\t * @defaultValue `'json'`\n\t */\n\tencoding: Encoding;\n\t/**\n\t * How long to wait for a shard to connect before giving up\n\t */\n\thandshakeTimeout: number | null;\n\t/**\n\t * How long to wait for a shard's HELLO packet before giving up\n\t */\n\thelloTimeout: number | null;\n\t/**\n\t * Properties to send to the gateway when identifying\n\t */\n\tidentifyProperties: GatewayIdentifyProperties;\n\t/**\n\t * Initial presence data to send to the gateway when identifying\n\t */\n\tinitialPresence: GatewayPresenceUpdateData | null;\n\t/**\n\t * Value between 50 and 250, total number of members where the gateway will stop sending offline members in the guild member list\n\t */\n\tlargeThreshold: number | null;\n\t/**\n\t * How long to wait for a shard's READY packet before giving up\n\t */\n\treadyTimeout: number | null;\n\t/**\n\t * Function used to retrieve session information (and attempt to resume) for a given shard\n\t *\n\t * @example\n\t * ```ts\n\t * const manager = new WebSocketManager({\n\t *   async retrieveSessionInfo(shardId): Awaitable<SessionInfo | null> {\n\t *     // Fetch this info from redis or similar\n\t *     return { sessionId: string, sequence: number };\n\t *     // Return null if no information is found\n\t *   },\n\t * });\n\t * ```\n\t */\n\tretrieveSessionInfo(shardId: number): Awaitable<SessionInfo | null>;\n\t/**\n\t * The total number of shards across all WebsocketManagers you intend to instantiate.\n\t * Use `null` to use Discord's recommended shard count\n\t */\n\tshardCount: number | null;\n\t/**\n\t * The ids of the shards this WebSocketManager should manage.\n\t * Use `null` to simply spawn 0 through `shardCount - 1`\n\t *\n\t * @example\n\t * ```ts\n\t * const manager = new WebSocketManager({\n\t *   shardIds: [1, 3, 7], // spawns shard 1, 3, and 7, nothing else\n\t * });\n\t * ```\n\t * @example\n\t * ```ts\n\t * const manager = new WebSocketManager({\n\t *   shardIds: {\n\t *     start: 3,\n\t *     end: 6,\n\t *   }, // spawns shards 3, 4, 5, and 6\n\t * });\n\t * ```\n\t */\n\tshardIds: number[] | ShardRange | null;\n\t/**\n\t * Function used to store session information for a given shard\n\t */\n\tupdateSessionInfo(shardId: number, sessionInfo: SessionInfo | null): Awaitable<void>;\n\t/**\n\t * The gateway version to use\n\t *\n\t * @defaultValue `'10'`\n\t */\n\tversion: string;\n}\n\nexport type WebSocketManagerOptions = OptionalWebSocketManagerOptions & RequiredWebSocketManagerOptions;\n\nexport type ManagerShardEventsMap = {\n\t[K in keyof WebSocketShardEventsMap]: [\n\t\tWebSocketShardEventsMap[K] extends [] ? { shardId: number } : WebSocketShardEventsMap[K][0] & { shardId: number },\n\t];\n};\n\nexport class WebSocketManager extends AsyncEventEmitter<ManagerShardEventsMap> {\n\t/**\n\t * The options being used by this manager\n\t */\n\tpublic readonly options: WebSocketManagerOptions;\n\n\t/**\n\t * Internal cache for a GET /gateway/bot result\n\t */\n\tprivate gatewayInformation: {\n\t\tdata: APIGatewayBotInfo;\n\t\texpiresAt: number;\n\t} | null = null;\n\n\t/**\n\t * Internal cache for the shard ids\n\t */\n\tprivate shardIds: number[] | null = null;\n\n\t/**\n\t * Strategy used to manage shards\n\t *\n\t * @defaultValue `SimpleManagerToShardStrategy`\n\t */\n\tprivate strategy: IShardingStrategy = new SimpleShardingStrategy(this);\n\n\tpublic constructor(options: Partial<OptionalWebSocketManagerOptions> & RequiredWebSocketManagerOptions) {\n\t\tsuper();\n\t\tthis.options = { ...DefaultWebSocketManagerOptions, ...options };\n\t}\n\n\tpublic setStrategy(strategy: IShardingStrategy) {\n\t\tthis.strategy = strategy;\n\t\treturn this;\n\t}\n\n\t/**\n\t * Fetches the gateway information from Discord - or returns it from cache if available\n\t *\n\t * @param force - Whether to ignore the cache and force a fresh fetch\n\t */\n\tpublic async fetchGatewayInformation(force = false) {\n\t\tif (this.gatewayInformation) {\n\t\t\tif (this.gatewayInformation.expiresAt <= Date.now()) {\n\t\t\t\tthis.gatewayInformation = null;\n\t\t\t} else if (!force) {\n\t\t\t\treturn this.gatewayInformation.data;\n\t\t\t}\n\t\t}\n\n\t\tconst data = (await this.options.rest.get(Routes.gatewayBot())) as RESTGetAPIGatewayBotResult;\n\n\t\tthis.gatewayInformation = { data, expiresAt: Date.now() + data.session_start_limit.reset_after };\n\t\treturn this.gatewayInformation.data;\n\t}\n\n\t/**\n\t * Updates your total shard count on-the-fly, spawning shards as needed\n\t *\n\t * @param shardCount - The new shard count to use\n\t */\n\tpublic async updateShardCount(shardCount: number | null) {\n\t\tawait this.strategy.destroy({ reason: 'User is adjusting their shards' });\n\t\tthis.options.shardCount = shardCount;\n\n\t\tconst shardIds = await this.getShardIds(true);\n\t\tawait this.strategy.spawn(shardIds);\n\n\t\treturn this;\n\t}\n\n\t/**\n\t * Yields the total number of shards across for your bot, accounting for Discord recommendations\n\t */\n\tpublic async getShardCount(): Promise<number> {\n\t\tif (this.options.shardCount) {\n\t\t\treturn this.options.shardCount;\n\t\t}\n\n\t\tconst shardIds = await this.getShardIds();\n\t\treturn Math.max(...shardIds) + 1;\n\t}\n\n\t/**\n\t * Yields the ids of the shards this manager should manage\n\t */\n\tpublic async getShardIds(force = false): Promise<number[]> {\n\t\tif (this.shardIds && !force) {\n\t\t\treturn this.shardIds;\n\t\t}\n\n\t\tlet shardIds: number[];\n\t\tif (this.options.shardIds) {\n\t\t\tif (Array.isArray(this.options.shardIds)) {\n\t\t\t\tshardIds = this.options.shardIds;\n\t\t\t} else {\n\t\t\t\tshardIds = range(this.options.shardIds.start, this.options.shardIds.end);\n\t\t\t}\n\t\t} else {\n\t\t\tconst data = await this.fetchGatewayInformation();\n\t\t\tshardIds = range(0, (this.options.shardCount ?? data.shards) - 1);\n\t\t}\n\n\t\tthis.shardIds = shardIds;\n\t\treturn shardIds;\n\t}\n\n\tpublic async connect() {\n\t\tconst shardCount = await this.getShardCount();\n\n\t\tconst data = await this.fetchGatewayInformation();\n\t\tif (data.session_start_limit.remaining < shardCount) {\n\t\t\tthrow new Error(\n\t\t\t\t`Not enough sessions remaining to spawn ${shardCount} shards; only ${\n\t\t\t\t\tdata.session_start_limit.remaining\n\t\t\t\t} remaining; resets at ${new Date(Date.now() + data.session_start_limit.reset_after).toISOString()}`,\n\t\t\t);\n\t\t}\n\n\t\t// First, make sure all our shards are spawned\n\t\tawait this.updateShardCount(shardCount);\n\t\tawait this.strategy.connect();\n\t}\n\n\tpublic destroy(options?: Omit<WebSocketShardDestroyOptions, 'recover'>) {\n\t\treturn this.strategy.destroy(options);\n\t}\n\n\tpublic send(shardId: number, payload: GatewaySendPayload) {\n\t\treturn this.strategy.send(shardId, payload);\n\t}\n}\n"],"mappings":"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","names":["sleep","import_node_worker_threads","import_collection","WorkerSendPayloadOp","WorkerRecievePayloadOp","import_collection","import_node_events","import_promises","import_collection","import_util","import_async_queue","import_v10","import_collection","Encoding","CompressionMethod","process","WebSocketShardEvents","WebSocketShardStatus","WebSocketShardDestroyRecovery","CloseCodes","version","sleep","import_util","import_async_event_emitter","import_v10"]}