{"version":3,"sources":["../src/strategies/sharding/worker.ts","../src/ws/WebSocketShard.ts","../src/utils/constants.ts","../src/strategies/context/WorkerContextFetchingStrategy.ts","../src/strategies/sharding/WorkerShardingStrategy.ts","../src/utils/IdentifyThrottler.ts"],"sourcesContent":["import { isMainThread, workerData, parentPort } from 'node:worker_threads';\nimport { Collection } from '@discordjs/collection';\nimport { WebSocketShard, WebSocketShardEvents, type WebSocketShardDestroyOptions } from '../../ws/WebSocketShard.js';\nimport { WorkerContextFetchingStrategy } from '../context/WorkerContextFetchingStrategy.js';\nimport {\n\tWorkerRecievePayloadOp,\n\tWorkerSendPayloadOp,\n\ttype WorkerData,\n\ttype WorkerRecievePayload,\n\ttype WorkerSendPayload,\n} from './WorkerShardingStrategy.js';\n\nif (isMainThread) {\n\tthrow new Error('Expected worker script to not be ran within the main thread');\n}\n\nconst data = workerData as WorkerData;\nconst shards = new Collection<number, WebSocketShard>();\n\nasync function connect(shardId: number) {\n\tconst shard = shards.get(shardId);\n\tif (!shard) {\n\t\tthrow new Error(`Shard ${shardId} does not exist`);\n\t}\n\n\tawait shard.connect();\n}\n\nasync function destroy(shardId: number, options?: WebSocketShardDestroyOptions) {\n\tconst shard = shards.get(shardId);\n\tif (!shard) {\n\t\tthrow new Error(`Shard ${shardId} does not exist`);\n\t}\n\n\tawait shard.destroy(options);\n}\n\nfor (const shardId of data.shardIds) {\n\tconst shard = new WebSocketShard(new WorkerContextFetchingStrategy(data), shardId);\n\tfor (const event of Object.values(WebSocketShardEvents)) {\n\t\t// @ts-expect-error: Event types incompatible\n\t\tshard.on(event, (data) => {\n\t\t\tconst payload = {\n\t\t\t\top: WorkerRecievePayloadOp.Event,\n\t\t\t\tevent,\n\t\t\t\tdata,\n\t\t\t\tshardId,\n\t\t\t} satisfies WorkerRecievePayload;\n\t\t\tparentPort!.postMessage(payload);\n\t\t});\n\t}\n\n\tshards.set(shardId, shard);\n}\n\nparentPort!\n\t.on('messageerror', (err) => {\n\t\tthrow err;\n\t})\n\t.on('message', async (payload: WorkerSendPayload) => {\n\t\tswitch (payload.op) {\n\t\t\tcase WorkerSendPayloadOp.Connect: {\n\t\t\t\tawait connect(payload.shardId);\n\t\t\t\tconst response: WorkerRecievePayload = {\n\t\t\t\t\top: WorkerRecievePayloadOp.Connected,\n\t\t\t\t\tshardId: payload.shardId,\n\t\t\t\t};\n\t\t\t\tparentPort!.postMessage(response);\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tcase WorkerSendPayloadOp.Destroy: {\n\t\t\t\tawait destroy(payload.shardId, payload.options);\n\t\t\t\tconst response: WorkerRecievePayload = {\n\t\t\t\t\top: WorkerRecievePayloadOp.Destroyed,\n\t\t\t\t\tshardId: payload.shardId,\n\t\t\t\t};\n\n\t\t\t\tparentPort!.postMessage(response);\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tcase WorkerSendPayloadOp.Send: {\n\t\t\t\tconst shard = shards.get(payload.shardId);\n\t\t\t\tif (!shard) {\n\t\t\t\t\tthrow new Error(`Shard ${payload.shardId} does not exist`);\n\t\t\t\t}\n\n\t\t\t\tawait shard.send(payload.payload);\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tcase WorkerSendPayloadOp.SessionInfoResponse: {\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tcase WorkerSendPayloadOp.ShardCanIdentify: {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t});\n","/* eslint-disable id-length */\nimport { Buffer } from 'node:buffer';\nimport { once } from 'node:events';\nimport { setTimeout, clearInterval, clearTimeout, setInterval } from 'node:timers';\nimport { setTimeout as sleep } from 'node:timers/promises';\nimport { URLSearchParams } from 'node:url';\nimport { TextDecoder } from 'node:util';\nimport { inflate } from 'node:zlib';\nimport { Collection } from '@discordjs/collection';\nimport { lazy } from '@discordjs/util';\nimport { AsyncQueue } from '@sapphire/async-queue';\nimport { AsyncEventEmitter } from '@vladfrangu/async_event_emitter';\nimport {\n\tGatewayCloseCodes,\n\tGatewayDispatchEvents,\n\tGatewayOpcodes,\n\ttype GatewayDispatchPayload,\n\ttype GatewayIdentifyData,\n\ttype GatewayReceivePayload,\n\ttype GatewaySendPayload,\n\ttype GatewayReadyDispatchData,\n} from 'discord-api-types/v10';\nimport { WebSocket, type RawData } from 'ws';\nimport type { Inflate } from 'zlib-sync';\nimport type { IContextFetchingStrategy } from '../strategies/context/IContextFetchingStrategy';\nimport { getInitialSendRateLimitState, ImportantGatewayOpcodes } from '../utils/constants.js';\nimport type { SessionInfo } from './WebSocketManager.js';\n\n// eslint-disable-next-line promise/prefer-await-to-then\nconst getZlibSync = lazy(async () => import('zlib-sync').then((mod) => mod.default).catch(() => null));\n\nexport enum WebSocketShardEvents {\n\tClosed = 'closed',\n\tDebug = 'debug',\n\tDispatch = 'dispatch',\n\tHello = 'hello',\n\tReady = 'ready',\n\tResumed = 'resumed',\n}\n\nexport enum WebSocketShardStatus {\n\tIdle,\n\tConnecting,\n\tResuming,\n\tReady,\n}\n\nexport enum WebSocketShardDestroyRecovery {\n\tReconnect,\n\tResume,\n}\n\n// eslint-disable-next-line @typescript-eslint/consistent-type-definitions\nexport type WebSocketShardEventsMap = {\n\t[WebSocketShardEvents.Closed]: [{ code: number }];\n\t[WebSocketShardEvents.Debug]: [payload: { message: string }];\n\t[WebSocketShardEvents.Hello]: [];\n\t[WebSocketShardEvents.Ready]: [payload: { data: GatewayReadyDispatchData }];\n\t[WebSocketShardEvents.Resumed]: [];\n\t[WebSocketShardEvents.Dispatch]: [payload: { data: GatewayDispatchPayload }];\n};\n\nexport interface WebSocketShardDestroyOptions {\n\tcode?: number;\n\treason?: string;\n\trecover?: WebSocketShardDestroyRecovery;\n}\n\nexport enum CloseCodes {\n\tNormal = 1_000,\n\tResuming = 4_200,\n}\n\nexport interface SendRateLimitState {\n\tremaining: number;\n\tresetAt: number;\n}\n\nexport class WebSocketShard extends AsyncEventEmitter<WebSocketShardEventsMap> {\n\tprivate connection: WebSocket | null = null;\n\n\tprivate readonly id: number;\n\n\tprivate useIdentifyCompress = false;\n\n\tprivate inflate: Inflate | null = null;\n\n\tprivate readonly textDecoder = new TextDecoder();\n\n\tprivate status: WebSocketShardStatus = WebSocketShardStatus.Idle;\n\n\tprivate replayedEvents = 0;\n\n\tprivate isAck = true;\n\n\tprivate sendRateLimitState: SendRateLimitState = getInitialSendRateLimitState();\n\n\tprivate heartbeatInterval: NodeJS.Timer | null = null;\n\n\tprivate lastHeartbeatAt = -1;\n\n\tprivate session: SessionInfo | null = null;\n\n\tprivate readonly sendQueue = new AsyncQueue();\n\n\tprivate readonly timeouts = new Collection<WebSocketShardEvents, NodeJS.Timeout>();\n\n\tpublic readonly strategy: IContextFetchingStrategy;\n\n\tpublic constructor(strategy: IContextFetchingStrategy, id: number) {\n\t\tsuper();\n\t\tthis.strategy = strategy;\n\t\tthis.id = id;\n\t}\n\n\tpublic async connect() {\n\t\tif (this.status !== WebSocketShardStatus.Idle) {\n\t\t\tthrow new Error(\"Tried to connect a shard that wasn't idle\");\n\t\t}\n\n\t\tconst { version, encoding, compression } = this.strategy.options;\n\t\tconst params = new URLSearchParams({ v: version, encoding });\n\t\tif (compression) {\n\t\t\tconst zlib = await getZlibSync();\n\t\t\tif (zlib) {\n\t\t\t\tparams.append('compress', compression);\n\t\t\t\tthis.inflate = new zlib.Inflate({\n\t\t\t\t\tchunkSize: 65_535,\n\t\t\t\t\tto: 'string',\n\t\t\t\t});\n\t\t\t} else if (!this.useIdentifyCompress) {\n\t\t\t\tthis.useIdentifyCompress = true;\n\t\t\t\tconsole.warn(\n\t\t\t\t\t'WebSocketShard: Compression is enabled but zlib-sync is not installed, falling back to identify compress',\n\t\t\t\t);\n\t\t\t}\n\t\t}\n\n\t\tconst session = this.session ?? (await this.strategy.retrieveSessionInfo(this.id));\n\n\t\tconst url = `${session?.resumeURL ?? this.strategy.options.gatewayInformation.url}?${params.toString()}`;\n\t\tthis.debug([`Connecting to ${url}`]);\n\t\tconst connection = new WebSocket(url, { handshakeTimeout: this.strategy.options.handshakeTimeout ?? undefined })\n\t\t\t.on('message', this.onMessage.bind(this))\n\t\t\t.on('error', this.onError.bind(this))\n\t\t\t.on('close', this.onClose.bind(this));\n\n\t\tconnection.binaryType = 'arraybuffer';\n\t\tthis.connection = connection;\n\n\t\tthis.status = WebSocketShardStatus.Connecting;\n\n\t\tthis.sendRateLimitState = getInitialSendRateLimitState();\n\n\t\tawait this.waitForEvent(WebSocketShardEvents.Hello, this.strategy.options.helloTimeout);\n\n\t\tif (session?.shardCount === this.strategy.options.shardCount) {\n\t\t\tthis.session = session;\n\t\t\tawait this.resume(session);\n\t\t} else {\n\t\t\tawait this.identify();\n\t\t}\n\t}\n\n\tpublic async destroy(options: WebSocketShardDestroyOptions = {}) {\n\t\tif (this.status === WebSocketShardStatus.Idle) {\n\t\t\tthis.debug(['Tried to destroy a shard that was idle']);\n\t\t\treturn;\n\t\t}\n\n\t\tif (!options.code) {\n\t\t\toptions.code = options.recover === WebSocketShardDestroyRecovery.Resume ? CloseCodes.Resuming : CloseCodes.Normal;\n\t\t}\n\n\t\tthis.debug([\n\t\t\t'Destroying shard',\n\t\t\t`Reason: ${options.reason ?? 'none'}`,\n\t\t\t`Code: ${options.code}`,\n\t\t\t`Recover: ${options.recover === undefined ? 'none' : WebSocketShardDestroyRecovery[options.recover]!}`,\n\t\t]);\n\n\t\t// Reset state\n\t\tthis.isAck = true;\n\t\tif (this.heartbeatInterval) {\n\t\t\tclearInterval(this.heartbeatInterval);\n\t\t}\n\n\t\tthis.lastHeartbeatAt = -1;\n\n\t\t// Clear session state if applicable\n\t\tif (options.recover !== WebSocketShardDestroyRecovery.Resume && this.session) {\n\t\t\tthis.session = null;\n\t\t\tawait this.strategy.updateSessionInfo(this.id, null);\n\t\t}\n\n\t\tif (this.connection) {\n\t\t\t// No longer need to listen to messages\n\t\t\tthis.connection.removeAllListeners('message');\n\t\t\t// Prevent a reconnection loop by unbinding the main close event\n\t\t\tthis.connection.removeAllListeners('close');\n\n\t\t\tconst shouldClose =\n\t\t\t\tthis.connection.readyState === WebSocket.OPEN || this.connection.readyState === WebSocket.CONNECTING;\n\n\t\t\tthis.debug([\n\t\t\t\t'Connection status during destroy',\n\t\t\t\t`Needs closing: ${shouldClose}`,\n\t\t\t\t`Ready state: ${this.connection.readyState}`,\n\t\t\t]);\n\n\t\t\tif (shouldClose) {\n\t\t\t\tthis.connection.close(options.code, options.reason);\n\t\t\t\tawait once(this.connection, 'close');\n\t\t\t\tthis.emit(WebSocketShardEvents.Closed, { code: options.code });\n\t\t\t}\n\n\t\t\t// Lastly, remove the error event.\n\t\t\t// Doing this earlier would cause a hard crash in case an error event fired on our `close` call\n\t\t\tthis.connection.removeAllListeners('error');\n\t\t} else {\n\t\t\tthis.debug(['Destroying a shard that has no connection; please open an issue on GitHub']);\n\t\t}\n\n\t\tthis.status = WebSocketShardStatus.Idle;\n\n\t\tif (options.recover !== undefined) {\n\t\t\treturn this.connect();\n\t\t}\n\t}\n\n\tprivate async waitForEvent(event: WebSocketShardEvents, timeoutDuration?: number | null) {\n\t\tthis.debug([`Waiting for event ${event} for ${timeoutDuration ? `${timeoutDuration}ms` : 'indefinitely'}`]);\n\t\tconst controller = new AbortController();\n\t\tconst timeout = timeoutDuration ? setTimeout(() => controller.abort(), timeoutDuration).unref() : null;\n\t\tif (timeout) {\n\t\t\tthis.timeouts.set(event, timeout);\n\t\t}\n\n\t\tawait once(this, event, { signal: controller.signal });\n\t\tif (timeout) {\n\t\t\tclearTimeout(timeout);\n\t\t\tthis.timeouts.delete(event);\n\t\t}\n\t}\n\n\tpublic async send(payload: GatewaySendPayload): Promise<void> {\n\t\tif (!this.connection) {\n\t\t\tthrow new Error(\"WebSocketShard wasn't connected\");\n\t\t}\n\n\t\tif (this.status !== WebSocketShardStatus.Ready && !ImportantGatewayOpcodes.has(payload.op)) {\n\t\t\tthis.debug(['Tried to send a non-crucial payload before the shard was ready, waiting']);\n\t\t\tawait once(this, WebSocketShardEvents.Ready);\n\t\t}\n\n\t\tawait this.sendQueue.wait();\n\n\t\tif (--this.sendRateLimitState.remaining <= 0) {\n\t\t\tconst now = Date.now();\n\n\t\t\tif (this.sendRateLimitState.resetAt > now) {\n\t\t\t\tconst sleepFor = this.sendRateLimitState.resetAt - now;\n\n\t\t\t\tthis.debug([`Was about to hit the send rate limit, sleeping for ${sleepFor}ms`]);\n\t\t\t\tconst controller = new AbortController();\n\n\t\t\t\t// Sleep for the remaining time, but if the connection closes in the meantime, we shouldn't wait the remainder to avoid blocking the new conn\n\t\t\t\tconst interrupted = await Promise.race([\n\t\t\t\t\tsleep(sleepFor).then(() => false),\n\t\t\t\t\tonce(this, WebSocketShardEvents.Closed, { signal: controller.signal }).then(() => true),\n\t\t\t\t]);\n\n\t\t\t\tif (interrupted) {\n\t\t\t\t\tthis.debug(['Connection closed while waiting for the send rate limit to reset, re-queueing payload']);\n\t\t\t\t\tthis.sendQueue.shift();\n\t\t\t\t\treturn this.send(payload);\n\t\t\t\t}\n\n\t\t\t\t// This is so the listener from the `once` call is removed\n\t\t\t\tcontroller.abort();\n\t\t\t}\n\n\t\t\tthis.sendRateLimitState = getInitialSendRateLimitState();\n\t\t}\n\n\t\tthis.sendQueue.shift();\n\t\tthis.connection.send(JSON.stringify(payload));\n\t}\n\n\tprivate async identify() {\n\t\tthis.debug([\n\t\t\t'Identifying',\n\t\t\t`shard id: ${this.id.toString()}`,\n\t\t\t`shard count: ${this.strategy.options.shardCount}`,\n\t\t\t`intents: ${this.strategy.options.intents}`,\n\t\t\t`compression: ${this.inflate ? 'zlib-stream' : this.useIdentifyCompress ? 'identify' : 'none'}`,\n\t\t]);\n\n\t\tawait this.strategy.waitForIdentify();\n\n\t\tconst d: GatewayIdentifyData = {\n\t\t\ttoken: this.strategy.options.token,\n\t\t\tproperties: this.strategy.options.identifyProperties,\n\t\t\tintents: this.strategy.options.intents,\n\t\t\tcompress: this.useIdentifyCompress,\n\t\t\tshard: [this.id, this.strategy.options.shardCount],\n\t\t};\n\n\t\tif (this.strategy.options.largeThreshold) {\n\t\t\td.large_threshold = this.strategy.options.largeThreshold;\n\t\t}\n\n\t\tif (this.strategy.options.initialPresence) {\n\t\t\td.presence = this.strategy.options.initialPresence;\n\t\t}\n\n\t\tawait this.send({\n\t\t\top: GatewayOpcodes.Identify,\n\t\t\td,\n\t\t});\n\n\t\tawait this.waitForEvent(WebSocketShardEvents.Ready, this.strategy.options.readyTimeout);\n\t\tthis.status = WebSocketShardStatus.Ready;\n\t}\n\n\tprivate async resume(session: SessionInfo) {\n\t\tthis.debug(['Resuming session']);\n\t\tthis.status = WebSocketShardStatus.Resuming;\n\t\tthis.replayedEvents = 0;\n\t\treturn this.send({\n\t\t\top: GatewayOpcodes.Resume,\n\t\t\td: {\n\t\t\t\ttoken: this.strategy.options.token,\n\t\t\t\tseq: session.sequence,\n\t\t\t\tsession_id: session.sessionId,\n\t\t\t},\n\t\t});\n\t}\n\n\tprivate async heartbeat(requested = false) {\n\t\tif (!this.isAck && !requested) {\n\t\t\treturn this.destroy({ reason: 'Zombie connection', recover: WebSocketShardDestroyRecovery.Resume });\n\t\t}\n\n\t\tawait this.send({\n\t\t\top: GatewayOpcodes.Heartbeat,\n\t\t\td: this.session?.sequence ?? null,\n\t\t});\n\n\t\tthis.lastHeartbeatAt = Date.now();\n\t\tthis.isAck = false;\n\t}\n\n\tprivate async unpackMessage(data: ArrayBuffer | Buffer, isBinary: boolean): Promise<GatewayReceivePayload | null> {\n\t\tconst decompressable = new Uint8Array(data);\n\n\t\t// Deal with no compression\n\t\tif (!isBinary) {\n\t\t\treturn JSON.parse(this.textDecoder.decode(decompressable)) as GatewayReceivePayload;\n\t\t}\n\n\t\t// Deal with identify compress\n\t\tif (this.useIdentifyCompress) {\n\t\t\treturn new Promise((resolve, reject) => {\n\t\t\t\tinflate(decompressable, { chunkSize: 65_535 }, (err, result) => {\n\t\t\t\t\tif (err) {\n\t\t\t\t\t\treject(err);\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\n\t\t\t\t\tresolve(JSON.parse(this.textDecoder.decode(result)) as GatewayReceivePayload);\n\t\t\t\t});\n\t\t\t});\n\t\t}\n\n\t\t// Deal with gw wide zlib-stream compression\n\t\tif (this.inflate) {\n\t\t\tconst l = decompressable.length;\n\t\t\tconst flush =\n\t\t\t\tl >= 4 &&\n\t\t\t\tdecompressable[l - 4] === 0x00 &&\n\t\t\t\tdecompressable[l - 3] === 0x00 &&\n\t\t\t\tdecompressable[l - 2] === 0xff &&\n\t\t\t\tdecompressable[l - 1] === 0xff;\n\n\t\t\tconst zlib = (await getZlibSync())!;\n\t\t\tthis.inflate.push(Buffer.from(decompressable), flush ? zlib.Z_SYNC_FLUSH : zlib.Z_NO_FLUSH);\n\n\t\t\tif (this.inflate.err) {\n\t\t\t\tthis.emit('error', `${this.inflate.err}${this.inflate.msg ? `: ${this.inflate.msg}` : ''}`);\n\t\t\t}\n\n\t\t\tif (!flush) {\n\t\t\t\treturn null;\n\t\t\t}\n\n\t\t\tconst { result } = this.inflate;\n\t\t\tif (!result) {\n\t\t\t\treturn null;\n\t\t\t}\n\n\t\t\treturn JSON.parse(typeof result === 'string' ? result : this.textDecoder.decode(result)) as GatewayReceivePayload;\n\t\t}\n\n\t\tthis.debug([\n\t\t\t'Received a message we were unable to decompress',\n\t\t\t`isBinary: ${isBinary.toString()}`,\n\t\t\t`useIdentifyCompress: ${this.useIdentifyCompress.toString()}`,\n\t\t\t`inflate: ${Boolean(this.inflate).toString()}`,\n\t\t]);\n\n\t\treturn null;\n\t}\n\n\tprivate async onMessage(data: RawData, isBinary: boolean) {\n\t\tconst payload = await this.unpackMessage(data as ArrayBuffer | Buffer, isBinary);\n\t\tif (!payload) {\n\t\t\treturn;\n\t\t}\n\n\t\tswitch (payload.op) {\n\t\t\tcase GatewayOpcodes.Dispatch: {\n\t\t\t\tif (this.status === WebSocketShardStatus.Resuming) {\n\t\t\t\t\tthis.replayedEvents++;\n\t\t\t\t}\n\n\t\t\t\t// eslint-disable-next-line sonarjs/no-nested-switch\n\t\t\t\tswitch (payload.t) {\n\t\t\t\t\tcase GatewayDispatchEvents.Ready: {\n\t\t\t\t\t\tthis.emit(WebSocketShardEvents.Ready, { data: payload.d });\n\n\t\t\t\t\t\tthis.session ??= {\n\t\t\t\t\t\t\tsequence: payload.s,\n\t\t\t\t\t\t\tsessionId: payload.d.session_id,\n\t\t\t\t\t\t\tshardId: this.id,\n\t\t\t\t\t\t\tshardCount: this.strategy.options.shardCount,\n\t\t\t\t\t\t\tresumeURL: payload.d.resume_gateway_url,\n\t\t\t\t\t\t};\n\n\t\t\t\t\t\tawait this.strategy.updateSessionInfo(this.id, this.session);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\n\t\t\t\t\tcase GatewayDispatchEvents.Resumed: {\n\t\t\t\t\t\tthis.status = WebSocketShardStatus.Ready;\n\t\t\t\t\t\tthis.debug([`Resumed and replayed ${this.replayedEvents} events`]);\n\t\t\t\t\t\tthis.emit(WebSocketShardEvents.Resumed);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\n\t\t\t\t\tdefault: {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (this.session && payload.s > this.session.sequence) {\n\t\t\t\t\tthis.session.sequence = payload.s;\n\t\t\t\t\tawait this.strategy.updateSessionInfo(this.id, this.session);\n\t\t\t\t}\n\n\t\t\t\tthis.emit(WebSocketShardEvents.Dispatch, { data: payload });\n\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tcase GatewayOpcodes.Heartbeat: {\n\t\t\t\tawait this.heartbeat(true);\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tcase GatewayOpcodes.Reconnect: {\n\t\t\t\tawait this.destroy({\n\t\t\t\t\treason: 'Told to reconnect by Discord',\n\t\t\t\t\trecover: WebSocketShardDestroyRecovery.Resume,\n\t\t\t\t});\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tcase GatewayOpcodes.InvalidSession: {\n\t\t\t\tconst readyTimeout = this.timeouts.get(WebSocketShardEvents.Ready);\n\t\t\t\treadyTimeout?.refresh();\n\t\t\t\tthis.debug([`Invalid session; will attempt to resume: ${payload.d.toString()}`]);\n\t\t\t\tconst session = this.session ?? (await this.strategy.retrieveSessionInfo(this.id));\n\t\t\t\tif (payload.d && session) {\n\t\t\t\t\tawait this.resume(session);\n\t\t\t\t} else {\n\t\t\t\t\tawait this.destroy({\n\t\t\t\t\t\treason: 'Invalid session',\n\t\t\t\t\t\trecover: WebSocketShardDestroyRecovery.Reconnect,\n\t\t\t\t\t});\n\t\t\t\t}\n\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tcase GatewayOpcodes.Hello: {\n\t\t\t\tthis.emit(WebSocketShardEvents.Hello);\n\t\t\t\tthis.debug([`Starting to heartbeat every ${payload.d.heartbeat_interval}ms`]);\n\t\t\t\tthis.heartbeatInterval = setInterval(() => void this.heartbeat(), payload.d.heartbeat_interval);\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tcase GatewayOpcodes.HeartbeatAck: {\n\t\t\t\tthis.isAck = true;\n\t\t\t\tthis.debug([`Got heartbeat ack after ${Date.now() - this.lastHeartbeatAt}ms`]);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate onError(err: Error) {\n\t\tthis.emit('error', err);\n\t}\n\n\tprivate async onClose(code: number) {\n\t\tthis.emit(WebSocketShardEvents.Closed, { code });\n\n\t\tswitch (code) {\n\t\t\tcase CloseCodes.Normal: {\n\t\t\t\treturn this.destroy({\n\t\t\t\t\tcode,\n\t\t\t\t\treason: 'Got disconnected by Discord',\n\t\t\t\t\trecover: WebSocketShardDestroyRecovery.Reconnect,\n\t\t\t\t});\n\t\t\t}\n\n\t\t\tcase CloseCodes.Resuming: {\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tcase GatewayCloseCodes.UnknownError: {\n\t\t\t\tthis.debug([`An unknown error occured: ${code}`]);\n\t\t\t\treturn this.destroy({ code, recover: WebSocketShardDestroyRecovery.Resume });\n\t\t\t}\n\n\t\t\tcase GatewayCloseCodes.UnknownOpcode: {\n\t\t\t\tthis.debug(['An invalid opcode was sent to Discord.']);\n\t\t\t\treturn this.destroy({ code, recover: WebSocketShardDestroyRecovery.Resume });\n\t\t\t}\n\n\t\t\tcase GatewayCloseCodes.DecodeError: {\n\t\t\t\tthis.debug(['An invalid payload was sent to Discord.']);\n\t\t\t\treturn this.destroy({ code, recover: WebSocketShardDestroyRecovery.Resume });\n\t\t\t}\n\n\t\t\tcase GatewayCloseCodes.NotAuthenticated: {\n\t\t\t\tthis.debug(['A request was somehow sent before the identify/resume payload.']);\n\t\t\t\treturn this.destroy({ code, recover: WebSocketShardDestroyRecovery.Reconnect });\n\t\t\t}\n\n\t\t\tcase GatewayCloseCodes.AuthenticationFailed: {\n\t\t\t\tthrow new Error('Authentication failed');\n\t\t\t}\n\n\t\t\tcase GatewayCloseCodes.AlreadyAuthenticated: {\n\t\t\t\tthis.debug(['More than one auth payload was sent.']);\n\t\t\t\treturn this.destroy({ code, recover: WebSocketShardDestroyRecovery.Reconnect });\n\t\t\t}\n\n\t\t\tcase GatewayCloseCodes.InvalidSeq: {\n\t\t\t\tthis.debug(['An invalid sequence was sent.']);\n\t\t\t\treturn this.destroy({ code, recover: WebSocketShardDestroyRecovery.Reconnect });\n\t\t\t}\n\n\t\t\tcase GatewayCloseCodes.RateLimited: {\n\t\t\t\tthis.debug(['The WebSocket rate limit has been hit, this should never happen']);\n\t\t\t\treturn this.destroy({ code, recover: WebSocketShardDestroyRecovery.Reconnect });\n\t\t\t}\n\n\t\t\tcase GatewayCloseCodes.SessionTimedOut: {\n\t\t\t\tthis.debug(['Session timed out.']);\n\t\t\t\treturn this.destroy({ code, recover: WebSocketShardDestroyRecovery.Resume });\n\t\t\t}\n\n\t\t\tcase GatewayCloseCodes.InvalidShard: {\n\t\t\t\tthrow new Error('Invalid shard');\n\t\t\t}\n\n\t\t\tcase GatewayCloseCodes.ShardingRequired: {\n\t\t\t\tthrow new Error('Sharding is required');\n\t\t\t}\n\n\t\t\tcase GatewayCloseCodes.InvalidAPIVersion: {\n\t\t\t\tthrow new Error('Used an invalid API version');\n\t\t\t}\n\n\t\t\tcase GatewayCloseCodes.InvalidIntents: {\n\t\t\t\tthrow new Error('Used invalid intents');\n\t\t\t}\n\n\t\t\tcase GatewayCloseCodes.DisallowedIntents: {\n\t\t\t\tthrow new Error('Used disallowed intents');\n\t\t\t}\n\n\t\t\tdefault: {\n\t\t\t\tthis.debug([`The gateway closed with an unexpected code ${code}, attempting to resume.`]);\n\t\t\t\treturn this.destroy({ code, recover: WebSocketShardDestroyRecovery.Resume });\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate debug(messages: [string, ...string[]]) {\n\t\tconst message = `${messages[0]}${\n\t\t\tmessages.length > 1\n\t\t\t\t? `\\n${messages\n\t\t\t\t\t\t.slice(1)\n\t\t\t\t\t\t.map((m) => `\t${m}`)\n\t\t\t\t\t\t.join('\\n')}`\n\t\t\t\t: ''\n\t\t}`;\n\n\t\tthis.emit(WebSocketShardEvents.Debug, { message });\n\t}\n}\n","import process from 'node:process';\nimport { Collection } from '@discordjs/collection';\nimport { lazy } from '@discordjs/util';\nimport { APIVersion, GatewayOpcodes } from 'discord-api-types/v10';\nimport type { SessionInfo, OptionalWebSocketManagerOptions } from '../ws/WebSocketManager.js';\nimport type { SendRateLimitState } from '../ws/WebSocketShard.js';\n\n/**\n * Valid encoding types\n */\nexport enum Encoding {\n\tJSON = 'json',\n}\n\n/**\n * Valid compression methods\n */\nexport enum CompressionMethod {\n\tZlibStream = 'zlib-stream',\n}\n\nexport const DefaultDeviceProperty = `@discordjs/ws 0.6.0`;\n\nconst getDefaultSessionStore = lazy(() => new Collection<number, SessionInfo | null>());\n\n/**\n * Default options used by the manager\n */\nexport const DefaultWebSocketManagerOptions = {\n\tshardCount: null,\n\tshardIds: null,\n\tlargeThreshold: null,\n\tinitialPresence: null,\n\tidentifyProperties: {\n\t\tbrowser: DefaultDeviceProperty,\n\t\tdevice: DefaultDeviceProperty,\n\t\tos: process.platform,\n\t},\n\tversion: APIVersion,\n\tencoding: Encoding.JSON,\n\tcompression: null,\n\tretrieveSessionInfo(shardId) {\n\t\tconst store = getDefaultSessionStore();\n\t\treturn store.get(shardId) ?? null;\n\t},\n\tupdateSessionInfo(shardId: number, info: SessionInfo | null) {\n\t\tconst store = getDefaultSessionStore();\n\t\tif (info) {\n\t\t\tstore.set(shardId, info);\n\t\t} else {\n\t\t\tstore.delete(shardId);\n\t\t}\n\t},\n\thandshakeTimeout: 30_000,\n\thelloTimeout: 60_000,\n\treadyTimeout: 15_000,\n} as const satisfies OptionalWebSocketManagerOptions;\n\nexport const ImportantGatewayOpcodes = new Set([\n\tGatewayOpcodes.Heartbeat,\n\tGatewayOpcodes.Identify,\n\tGatewayOpcodes.Resume,\n]);\n\nexport function getInitialSendRateLimitState(): SendRateLimitState {\n\treturn {\n\t\tremaining: 120,\n\t\tresetAt: Date.now() + 60_000,\n\t};\n}\n","import { isMainThread, parentPort } from 'node:worker_threads';\nimport { Collection } from '@discordjs/collection';\nimport type { SessionInfo } from '../../ws/WebSocketManager.js';\nimport {\n\tWorkerRecievePayloadOp,\n\tWorkerSendPayloadOp,\n\ttype WorkerRecievePayload,\n\ttype WorkerSendPayload,\n} from '../sharding/WorkerShardingStrategy.js';\nimport type { FetchingStrategyOptions, IContextFetchingStrategy } from './IContextFetchingStrategy.js';\n\nexport class WorkerContextFetchingStrategy implements IContextFetchingStrategy {\n\tprivate readonly sessionPromises = new Collection<number, (session: SessionInfo | null) => void>();\n\n\tprivate readonly waitForIdentifyPromises = new Collection<number, () => void>();\n\n\tpublic constructor(public readonly options: FetchingStrategyOptions) {\n\t\tif (isMainThread) {\n\t\t\tthrow new Error('Cannot instantiate WorkerContextFetchingStrategy on the main thread');\n\t\t}\n\n\t\tparentPort!.on('message', (payload: WorkerSendPayload) => {\n\t\t\tif (payload.op === WorkerSendPayloadOp.SessionInfoResponse) {\n\t\t\t\tthis.sessionPromises.get(payload.nonce)?.(payload.session);\n\t\t\t\tthis.sessionPromises.delete(payload.nonce);\n\t\t\t}\n\n\t\t\tif (payload.op === WorkerSendPayloadOp.ShardCanIdentify) {\n\t\t\t\tthis.waitForIdentifyPromises.get(payload.nonce)?.();\n\t\t\t\tthis.waitForIdentifyPromises.delete(payload.nonce);\n\t\t\t}\n\t\t});\n\t}\n\n\tpublic async retrieveSessionInfo(shardId: number): Promise<SessionInfo | null> {\n\t\tconst nonce = Math.random();\n\t\tconst payload = {\n\t\t\top: WorkerRecievePayloadOp.RetrieveSessionInfo,\n\t\t\tshardId,\n\t\t\tnonce,\n\t\t} satisfies WorkerRecievePayload;\n\t\t// eslint-disable-next-line no-promise-executor-return\n\t\tconst promise = new Promise<SessionInfo | null>((resolve) => this.sessionPromises.set(nonce, resolve));\n\t\tparentPort!.postMessage(payload);\n\t\treturn promise;\n\t}\n\n\tpublic updateSessionInfo(shardId: number, sessionInfo: SessionInfo | null) {\n\t\tconst payload = {\n\t\t\top: WorkerRecievePayloadOp.UpdateSessionInfo,\n\t\t\tshardId,\n\t\t\tsession: sessionInfo,\n\t\t} satisfies WorkerRecievePayload;\n\t\tparentPort!.postMessage(payload);\n\t}\n\n\tpublic async waitForIdentify(): Promise<void> {\n\t\tconst nonce = Math.random();\n\t\tconst payload = {\n\t\t\top: WorkerRecievePayloadOp.WaitForIdentify,\n\t\t\tnonce,\n\t\t} satisfies WorkerRecievePayload;\n\t\t// eslint-disable-next-line no-promise-executor-return\n\t\tconst promise = new Promise<void>((resolve) => this.waitForIdentifyPromises.set(nonce, resolve));\n\t\tparentPort!.postMessage(payload);\n\t\treturn promise;\n\t}\n}\n","import { once } from 'node:events';\nimport { join } from 'node:path';\nimport { Worker } from 'node:worker_threads';\nimport { Collection } from '@discordjs/collection';\nimport type { GatewaySendPayload } from 'discord-api-types/v10';\nimport { IdentifyThrottler } from '../../utils/IdentifyThrottler.js';\nimport type { SessionInfo, WebSocketManager } from '../../ws/WebSocketManager';\nimport type { WebSocketShardDestroyOptions, WebSocketShardEvents } from '../../ws/WebSocketShard';\nimport { managerToFetchingStrategyOptions, type FetchingStrategyOptions } from '../context/IContextFetchingStrategy.js';\nimport type { IShardingStrategy } from './IShardingStrategy.js';\n\nexport interface WorkerData extends FetchingStrategyOptions {\n\tshardIds: number[];\n}\n\nexport enum WorkerSendPayloadOp {\n\tConnect,\n\tDestroy,\n\tSend,\n\tSessionInfoResponse,\n\tShardCanIdentify,\n}\n\nexport type WorkerSendPayload =\n\t| { nonce: number; op: WorkerSendPayloadOp.SessionInfoResponse; session: SessionInfo | null }\n\t| { nonce: number; op: WorkerSendPayloadOp.ShardCanIdentify }\n\t| { op: WorkerSendPayloadOp.Connect; shardId: number }\n\t| { op: WorkerSendPayloadOp.Destroy; options?: WebSocketShardDestroyOptions; shardId: number }\n\t| { op: WorkerSendPayloadOp.Send; payload: GatewaySendPayload; shardId: number };\n\nexport enum WorkerRecievePayloadOp {\n\tConnected,\n\tDestroyed,\n\tEvent,\n\tRetrieveSessionInfo,\n\tUpdateSessionInfo,\n\tWaitForIdentify,\n}\n\nexport type WorkerRecievePayload =\n\t// Can't seem to get a type-safe union based off of the event, so I'm sadly leaving data as any for now\n\t| { data: any; event: WebSocketShardEvents; op: WorkerRecievePayloadOp.Event; shardId: number }\n\t| { nonce: number; op: WorkerRecievePayloadOp.RetrieveSessionInfo; shardId: number }\n\t| { nonce: number; op: WorkerRecievePayloadOp.WaitForIdentify }\n\t| { op: WorkerRecievePayloadOp.Connected; shardId: number }\n\t| { op: WorkerRecievePayloadOp.Destroyed; shardId: number }\n\t| { op: WorkerRecievePayloadOp.UpdateSessionInfo; session: SessionInfo | null; shardId: number };\n\n/**\n * Options for a {@link WorkerShardingStrategy}\n */\nexport interface WorkerShardingStrategyOptions {\n\t/**\n\t * Dictates how many shards should be spawned per worker thread.\n\t */\n\tshardsPerWorker: number | 'all';\n}\n\n/**\n * Strategy used to spawn threads in worker_threads\n */\nexport class WorkerShardingStrategy implements IShardingStrategy {\n\tprivate readonly manager: WebSocketManager;\n\n\tprivate readonly options: WorkerShardingStrategyOptions;\n\n\t#workers: Worker[] = [];\n\n\treadonly #workerByShardId = new Collection<number, Worker>();\n\n\tprivate readonly connectPromises = new Collection<number, () => void>();\n\n\tprivate readonly destroyPromises = new Collection<number, () => void>();\n\n\tprivate readonly throttler: IdentifyThrottler;\n\n\tpublic constructor(manager: WebSocketManager, options: WorkerShardingStrategyOptions) {\n\t\tthis.manager = manager;\n\t\tthis.throttler = new IdentifyThrottler(manager);\n\t\tthis.options = options;\n\t}\n\n\t/**\n\t * {@inheritDoc IShardingStrategy.spawn}\n\t */\n\tpublic async spawn(shardIds: number[]) {\n\t\tconst shardsPerWorker = this.options.shardsPerWorker === 'all' ? shardIds.length : this.options.shardsPerWorker;\n\t\tconst strategyOptions = await managerToFetchingStrategyOptions(this.manager);\n\n\t\tlet shards = 0;\n\t\twhile (shards !== shardIds.length) {\n\t\t\tconst slice = shardIds.slice(shards, shardsPerWorker + shards);\n\t\t\tconst workerData: WorkerData = {\n\t\t\t\t...strategyOptions,\n\t\t\t\tshardIds: slice,\n\t\t\t};\n\n\t\t\tconst worker = new Worker(join(__dirname, 'worker.js'), { workerData });\n\t\t\tawait once(worker, 'online');\n\t\t\tworker\n\t\t\t\t.on('error', (err) => {\n\t\t\t\t\tthrow err;\n\t\t\t\t})\n\t\t\t\t.on('messageerror', (err) => {\n\t\t\t\t\tthrow err;\n\t\t\t\t})\n\t\t\t\t.on('message', async (payload: WorkerRecievePayload) => this.onMessage(worker, payload));\n\n\t\t\tthis.#workers.push(worker);\n\t\t\tfor (const shardId of slice) {\n\t\t\t\tthis.#workerByShardId.set(shardId, worker);\n\t\t\t}\n\n\t\t\tshards += slice.length;\n\t\t}\n\t}\n\n\t/**\n\t * {@inheritDoc IShardingStrategy.connect}\n\t */\n\tpublic async connect() {\n\t\tconst promises = [];\n\n\t\tfor (const [shardId, worker] of this.#workerByShardId.entries()) {\n\t\t\tconst payload = {\n\t\t\t\top: WorkerSendPayloadOp.Connect,\n\t\t\t\tshardId,\n\t\t\t} satisfies WorkerSendPayload;\n\n\t\t\t// eslint-disable-next-line no-promise-executor-return\n\t\t\tconst promise = new Promise<void>((resolve) => this.connectPromises.set(shardId, resolve));\n\t\t\tworker.postMessage(payload);\n\t\t\tpromises.push(promise);\n\t\t}\n\n\t\tawait Promise.all(promises);\n\t}\n\n\t/**\n\t * {@inheritDoc IShardingStrategy.destroy}\n\t */\n\tpublic async destroy(options: Omit<WebSocketShardDestroyOptions, 'recover'> = {}) {\n\t\tconst promises = [];\n\n\t\tfor (const [shardId, worker] of this.#workerByShardId.entries()) {\n\t\t\tconst payload = {\n\t\t\t\top: WorkerSendPayloadOp.Destroy,\n\t\t\t\tshardId,\n\t\t\t\toptions,\n\t\t\t} satisfies WorkerSendPayload;\n\n\t\t\tpromises.push(\n\t\t\t\t// eslint-disable-next-line no-promise-executor-return, promise/prefer-await-to-then\n\t\t\t\tnew Promise<void>((resolve) => this.destroyPromises.set(shardId, resolve)).then(async () => worker.terminate()),\n\t\t\t);\n\t\t\tworker.postMessage(payload);\n\t\t}\n\n\t\tthis.#workers = [];\n\t\tthis.#workerByShardId.clear();\n\n\t\tawait Promise.all(promises);\n\t}\n\n\t/**\n\t * {@inheritDoc IShardingStrategy.send}\n\t */\n\tpublic send(shardId: number, data: GatewaySendPayload) {\n\t\tconst worker = this.#workerByShardId.get(shardId);\n\t\tif (!worker) {\n\t\t\tthrow new Error(`No worker found for shard ${shardId}`);\n\t\t}\n\n\t\tconst payload = {\n\t\t\top: WorkerSendPayloadOp.Send,\n\t\t\tshardId,\n\t\t\tpayload: data,\n\t\t} satisfies WorkerSendPayload;\n\t\tworker.postMessage(payload);\n\t}\n\n\tprivate async onMessage(worker: Worker, payload: WorkerRecievePayload) {\n\t\tswitch (payload.op) {\n\t\t\tcase WorkerRecievePayloadOp.Connected: {\n\t\t\t\tconst resolve = this.connectPromises.get(payload.shardId)!;\n\t\t\t\tresolve();\n\t\t\t\tthis.connectPromises.delete(payload.shardId);\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tcase WorkerRecievePayloadOp.Destroyed: {\n\t\t\t\tconst resolve = this.destroyPromises.get(payload.shardId)!;\n\t\t\t\tresolve();\n\t\t\t\tthis.destroyPromises.delete(payload.shardId);\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tcase WorkerRecievePayloadOp.Event: {\n\t\t\t\tthis.manager.emit(payload.event, { ...payload.data, shardId: payload.shardId });\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tcase WorkerRecievePayloadOp.RetrieveSessionInfo: {\n\t\t\t\tconst session = await this.manager.options.retrieveSessionInfo(payload.shardId);\n\t\t\t\tconst response: WorkerSendPayload = {\n\t\t\t\t\top: WorkerSendPayloadOp.SessionInfoResponse,\n\t\t\t\t\tnonce: payload.nonce,\n\t\t\t\t\tsession,\n\t\t\t\t};\n\t\t\t\tworker.postMessage(response);\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tcase WorkerRecievePayloadOp.UpdateSessionInfo: {\n\t\t\t\tawait this.manager.options.updateSessionInfo(payload.shardId, payload.session);\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tcase WorkerRecievePayloadOp.WaitForIdentify: {\n\t\t\t\tawait this.throttler.waitForIdentify();\n\t\t\t\tconst response: WorkerSendPayload = {\n\t\t\t\t\top: WorkerSendPayloadOp.ShardCanIdentify,\n\t\t\t\t\tnonce: payload.nonce,\n\t\t\t\t};\n\t\t\t\tworker.postMessage(response);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n}\n","import { setTimeout as sleep } from 'node:timers/promises';\nimport { AsyncQueue } from '@sapphire/async-queue';\nimport type { WebSocketManager } from '../ws/WebSocketManager.js';\n\nexport class IdentifyThrottler {\n\tprivate readonly queue = new AsyncQueue();\n\n\tprivate identifyState = {\n\t\tremaining: 0,\n\t\tresetsAt: Number.POSITIVE_INFINITY,\n\t};\n\n\tpublic constructor(private readonly manager: WebSocketManager) {}\n\n\tpublic async waitForIdentify(): Promise<void> {\n\t\tawait this.queue.wait();\n\n\t\ttry {\n\t\t\tif (this.identifyState.remaining <= 0) {\n\t\t\t\tconst diff = this.identifyState.resetsAt - Date.now();\n\t\t\t\tif (diff <= 5_000) {\n\t\t\t\t\t// To account for the latency the IDENTIFY payload goes through, we add a bit more wait time\n\t\t\t\t\tconst time = diff + Math.random() * 1_500;\n\t\t\t\t\tawait sleep(time);\n\t\t\t\t}\n\n\t\t\t\tconst info = await this.manager.fetchGatewayInformation();\n\t\t\t\tthis.identifyState = {\n\t\t\t\t\tremaining: info.session_start_limit.max_concurrency,\n\t\t\t\t\tresetsAt: Date.now() + 5_000,\n\t\t\t\t};\n\t\t\t}\n\n\t\t\tthis.identifyState.remaining--;\n\t\t} finally {\n\t\t\tthis.queue.shift();\n\t\t}\n\t}\n}\n"],"mappings":";;;;AAAA,SAAS,gBAAAA,eAAc,YAAY,cAAAC,mBAAkB;AACrD,SAAS,cAAAC,mBAAkB;;;ACA3B,SAAS,UAAAC,eAAc;AACvB,SAAS,YAAY;AACrB,SAAS,YAAY,eAAe,cAAc,mBAAmB;AACrE,SAAS,cAAc,aAAa;AACpC,SAAS,uBAAuB;AAChC,SAAS,mBAAmB;AAC5B,SAAS,eAAe;AACxB,SAAS,cAAAC,mBAAkB;AAC3B,SAAS,QAAAC,aAAY;AACrB,SAAS,kBAAkB;AAC3B,SAAS,yBAAyB;AAClC;AAAA,EACC;AAAA,EACA;AAAA,EACA,kBAAAC;AAAA,OAMM;AACP,SAAS,iBAA+B;;;ACtBxC,OAAO,aAAa;AACpB,SAAS,kBAAkB;AAC3B,SAAS,YAAY;AACrB,SAAS,YAAY,sBAAsB;AAkBpC,IAAM,wBAAwB;AAErC,IAAM,yBAAyB,KAAK,MAAM,IAAI,WAAuC,CAAC;AAK/E,IAAM,iCAAiC;AAAA,EAC7C,YAAY;AAAA,EACZ,UAAU;AAAA,EACV,gBAAgB;AAAA,EAChB,iBAAiB;AAAA,EACjB,oBAAoB;AAAA,IACnB,SAAS;AAAA,IACT,QAAQ;AAAA,IACR,IAAI,QAAQ;AAAA,EACb;AAAA,EACA,SAAS;AAAA,EACT,UAAU;AAAA,EACV,aAAa;AAAA,EACb,oBAAoB,SAAS;AAC5B,UAAM,QAAQ,uBAAuB;AACrC,WAAO,MAAM,IAAI,OAAO,KAAK;AAAA,EAC9B;AAAA,EACA,kBAAkB,SAAiB,MAA0B;AAC5D,UAAM,QAAQ,uBAAuB;AACrC,QAAI,MAAM;AACT,YAAM,IAAI,SAAS,IAAI;AAAA,IACxB,OAAO;AACN,YAAM,OAAO,OAAO;AAAA,IACrB;AAAA,EACD;AAAA,EACA,kBAAkB;AAAA,EAClB,cAAc;AAAA,EACd,cAAc;AACf;AAEO,IAAM,0BAA0B,oBAAI,IAAI;AAAA,EAC9C,eAAe;AAAA,EACf,eAAe;AAAA,EACf,eAAe;AAChB,CAAC;AAEM,SAAS,+BAAmD;AAClE,SAAO;AAAA,IACN,WAAW;AAAA,IACX,SAAS,KAAK,IAAI,IAAI;AAAA,EACvB;AACD;AALgB;;;ADnChB,IAAM,cAAcC,MAAK,YAAY,OAAO,aAAa,KAAK,CAAC,QAAQ,IAAI,OAAO,EAAE,MAAM,MAAM,IAAI,CAAC;AAE9F,IAAK,uBAAL,kBAAKC,0BAAL;AACN,EAAAA,sBAAA,YAAS;AACT,EAAAA,sBAAA,WAAQ;AACR,EAAAA,sBAAA,cAAW;AACX,EAAAA,sBAAA,WAAQ;AACR,EAAAA,sBAAA,WAAQ;AACR,EAAAA,sBAAA,aAAU;AANC,SAAAA;AAAA,GAAA;AAgBL,IAAK,gCAAL,kBAAKC,mCAAL;AACN,EAAAA,8DAAA;AACA,EAAAA,8DAAA;AAFW,SAAAA;AAAA,GAAA;AA+BL,IAAM,iBAAN,cAA6B,kBAA2C;AAAA,EACtE,aAA+B;AAAA,EAEtB;AAAA,EAET,sBAAsB;AAAA,EAEtB,UAA0B;AAAA,EAEjB,cAAc,IAAI,YAAY;AAAA,EAEvC,SAA+B;AAAA,EAE/B,iBAAiB;AAAA,EAEjB,QAAQ;AAAA,EAER,qBAAyC,6BAA6B;AAAA,EAEtE,oBAAyC;AAAA,EAEzC,kBAAkB;AAAA,EAElB,UAA8B;AAAA,EAErB,YAAY,IAAI,WAAW;AAAA,EAE3B,WAAW,IAAIC,YAAiD;AAAA,EAEjE;AAAA,EAET,YAAY,UAAoC,IAAY;AAClE,UAAM;AACN,SAAK,WAAW;AAChB,SAAK,KAAK;AAAA,EACX;AAAA,EAEA,MAAa,UAAU;AACtB,QAAI,KAAK,WAAW,cAA2B;AAC9C,YAAM,IAAI,MAAM,2CAA2C;AAAA,IAC5D;AAEA,UAAM,EAAE,SAAS,UAAU,YAAY,IAAI,KAAK,SAAS;AACzD,UAAM,SAAS,IAAI,gBAAgB,EAAE,GAAG,SAAS,SAAS,CAAC;AAC3D,QAAI,aAAa;AAChB,YAAM,OAAO,MAAM,YAAY;AAC/B,UAAI,MAAM;AACT,eAAO,OAAO,YAAY,WAAW;AACrC,aAAK,UAAU,IAAI,KAAK,QAAQ;AAAA,UAC/B,WAAW;AAAA,UACX,IAAI;AAAA,QACL,CAAC;AAAA,MACF,WAAW,CAAC,KAAK,qBAAqB;AACrC,aAAK,sBAAsB;AAC3B,gBAAQ;AAAA,UACP;AAAA,QACD;AAAA,MACD;AAAA,IACD;AAEA,UAAM,UAAU,KAAK,WAAY,MAAM,KAAK,SAAS,oBAAoB,KAAK,EAAE;AAEhF,UAAM,MAAM,GAAG,SAAS,aAAa,KAAK,SAAS,QAAQ,mBAAmB,OAAO,OAAO,SAAS;AACrG,SAAK,MAAM,CAAC,iBAAiB,KAAK,CAAC;AACnC,UAAM,aAAa,IAAI,UAAU,KAAK,EAAE,kBAAkB,KAAK,SAAS,QAAQ,oBAAoB,OAAU,CAAC,EAC7G,GAAG,WAAW,KAAK,UAAU,KAAK,IAAI,CAAC,EACvC,GAAG,SAAS,KAAK,QAAQ,KAAK,IAAI,CAAC,EACnC,GAAG,SAAS,KAAK,QAAQ,KAAK,IAAI,CAAC;AAErC,eAAW,aAAa;AACxB,SAAK,aAAa;AAElB,SAAK,SAAS;AAEd,SAAK,qBAAqB,6BAA6B;AAEvD,UAAM,KAAK,aAAa,qBAA4B,KAAK,SAAS,QAAQ,YAAY;AAEtF,QAAI,SAAS,eAAe,KAAK,SAAS,QAAQ,YAAY;AAC7D,WAAK,UAAU;AACf,YAAM,KAAK,OAAO,OAAO;AAAA,IAC1B,OAAO;AACN,YAAM,KAAK,SAAS;AAAA,IACrB;AAAA,EACD;AAAA,EAEA,MAAa,QAAQ,UAAwC,CAAC,GAAG;AAChE,QAAI,KAAK,WAAW,cAA2B;AAC9C,WAAK,MAAM,CAAC,wCAAwC,CAAC;AACrD;AAAA,IACD;AAEA,QAAI,CAAC,QAAQ,MAAM;AAClB,cAAQ,OAAO,QAAQ,YAAY,iBAAuC,sBAAsB;AAAA,IACjG;AAEA,SAAK,MAAM;AAAA,MACV;AAAA,MACA,WAAW,QAAQ,UAAU;AAAA,MAC7B,SAAS,QAAQ;AAAA,MACjB,YAAY,QAAQ,YAAY,SAAY,SAAS,8BAA8B,QAAQ;AAAA,IAC5F,CAAC;AAGD,SAAK,QAAQ;AACb,QAAI,KAAK,mBAAmB;AAC3B,oBAAc,KAAK,iBAAiB;AAAA,IACrC;AAEA,SAAK,kBAAkB;AAGvB,QAAI,QAAQ,YAAY,kBAAwC,KAAK,SAAS;AAC7E,WAAK,UAAU;AACf,YAAM,KAAK,SAAS,kBAAkB,KAAK,IAAI,IAAI;AAAA,IACpD;AAEA,QAAI,KAAK,YAAY;AAEpB,WAAK,WAAW,mBAAmB,SAAS;AAE5C,WAAK,WAAW,mBAAmB,OAAO;AAE1C,YAAM,cACL,KAAK,WAAW,eAAe,UAAU,QAAQ,KAAK,WAAW,eAAe,UAAU;AAE3F,WAAK,MAAM;AAAA,QACV;AAAA,QACA,kBAAkB;AAAA,QAClB,gBAAgB,KAAK,WAAW;AAAA,MACjC,CAAC;AAED,UAAI,aAAa;AAChB,aAAK,WAAW,MAAM,QAAQ,MAAM,QAAQ,MAAM;AAClD,cAAM,KAAK,KAAK,YAAY,OAAO;AACnC,aAAK,KAAK,uBAA6B,EAAE,MAAM,QAAQ,KAAK,CAAC;AAAA,MAC9D;AAIA,WAAK,WAAW,mBAAmB,OAAO;AAAA,IAC3C,OAAO;AACN,WAAK,MAAM,CAAC,2EAA2E,CAAC;AAAA,IACzF;AAEA,SAAK,SAAS;AAEd,QAAI,QAAQ,YAAY,QAAW;AAClC,aAAO,KAAK,QAAQ;AAAA,IACrB;AAAA,EACD;AAAA,EAEA,MAAc,aAAa,OAA6B,iBAAiC;AACxF,SAAK,MAAM,CAAC,qBAAqB,aAAa,kBAAkB,GAAG,sBAAsB,gBAAgB,CAAC;AAC1G,UAAM,aAAa,IAAI,gBAAgB;AACvC,UAAM,UAAU,kBAAkB,WAAW,MAAM,WAAW,MAAM,GAAG,eAAe,EAAE,MAAM,IAAI;AAClG,QAAI,SAAS;AACZ,WAAK,SAAS,IAAI,OAAO,OAAO;AAAA,IACjC;AAEA,UAAM,KAAK,MAAM,OAAO,EAAE,QAAQ,WAAW,OAAO,CAAC;AACrD,QAAI,SAAS;AACZ,mBAAa,OAAO;AACpB,WAAK,SAAS,OAAO,KAAK;AAAA,IAC3B;AAAA,EACD;AAAA,EAEA,MAAa,KAAK,SAA4C;AAC7D,QAAI,CAAC,KAAK,YAAY;AACrB,YAAM,IAAI,MAAM,iCAAiC;AAAA,IAClD;AAEA,QAAI,KAAK,WAAW,iBAA8B,CAAC,wBAAwB,IAAI,QAAQ,EAAE,GAAG;AAC3F,WAAK,MAAM,CAAC,yEAAyE,CAAC;AACtF,YAAM,KAAK,MAAM,mBAA0B;AAAA,IAC5C;AAEA,UAAM,KAAK,UAAU,KAAK;AAE1B,QAAI,EAAE,KAAK,mBAAmB,aAAa,GAAG;AAC7C,YAAM,MAAM,KAAK,IAAI;AAErB,UAAI,KAAK,mBAAmB,UAAU,KAAK;AAC1C,cAAM,WAAW,KAAK,mBAAmB,UAAU;AAEnD,aAAK,MAAM,CAAC,sDAAsD,YAAY,CAAC;AAC/E,cAAM,aAAa,IAAI,gBAAgB;AAGvC,cAAM,cAAc,MAAM,QAAQ,KAAK;AAAA,UACtC,MAAM,QAAQ,EAAE,KAAK,MAAM,KAAK;AAAA,UAChC,KAAK,MAAM,uBAA6B,EAAE,QAAQ,WAAW,OAAO,CAAC,EAAE,KAAK,MAAM,IAAI;AAAA,QACvF,CAAC;AAED,YAAI,aAAa;AAChB,eAAK,MAAM,CAAC,uFAAuF,CAAC;AACpG,eAAK,UAAU,MAAM;AACrB,iBAAO,KAAK,KAAK,OAAO;AAAA,QACzB;AAGA,mBAAW,MAAM;AAAA,MAClB;AAEA,WAAK,qBAAqB,6BAA6B;AAAA,IACxD;AAEA,SAAK,UAAU,MAAM;AACrB,SAAK,WAAW,KAAK,KAAK,UAAU,OAAO,CAAC;AAAA,EAC7C;AAAA,EAEA,MAAc,WAAW;AACxB,SAAK,MAAM;AAAA,MACV;AAAA,MACA,aAAa,KAAK,GAAG,SAAS;AAAA,MAC9B,gBAAgB,KAAK,SAAS,QAAQ;AAAA,MACtC,YAAY,KAAK,SAAS,QAAQ;AAAA,MAClC,gBAAgB,KAAK,UAAU,gBAAgB,KAAK,sBAAsB,aAAa;AAAA,IACxF,CAAC;AAED,UAAM,KAAK,SAAS,gBAAgB;AAEpC,UAAM,IAAyB;AAAA,MAC9B,OAAO,KAAK,SAAS,QAAQ;AAAA,MAC7B,YAAY,KAAK,SAAS,QAAQ;AAAA,MAClC,SAAS,KAAK,SAAS,QAAQ;AAAA,MAC/B,UAAU,KAAK;AAAA,MACf,OAAO,CAAC,KAAK,IAAI,KAAK,SAAS,QAAQ,UAAU;AAAA,IAClD;AAEA,QAAI,KAAK,SAAS,QAAQ,gBAAgB;AACzC,QAAE,kBAAkB,KAAK,SAAS,QAAQ;AAAA,IAC3C;AAEA,QAAI,KAAK,SAAS,QAAQ,iBAAiB;AAC1C,QAAE,WAAW,KAAK,SAAS,QAAQ;AAAA,IACpC;AAEA,UAAM,KAAK,KAAK;AAAA,MACf,IAAIC,gBAAe;AAAA,MACnB;AAAA,IACD,CAAC;AAED,UAAM,KAAK,aAAa,qBAA4B,KAAK,SAAS,QAAQ,YAAY;AACtF,SAAK,SAAS;AAAA,EACf;AAAA,EAEA,MAAc,OAAO,SAAsB;AAC1C,SAAK,MAAM,CAAC,kBAAkB,CAAC;AAC/B,SAAK,SAAS;AACd,SAAK,iBAAiB;AACtB,WAAO,KAAK,KAAK;AAAA,MAChB,IAAIA,gBAAe;AAAA,MACnB,GAAG;AAAA,QACF,OAAO,KAAK,SAAS,QAAQ;AAAA,QAC7B,KAAK,QAAQ;AAAA,QACb,YAAY,QAAQ;AAAA,MACrB;AAAA,IACD,CAAC;AAAA,EACF;AAAA,EAEA,MAAc,UAAU,YAAY,OAAO;AAC1C,QAAI,CAAC,KAAK,SAAS,CAAC,WAAW;AAC9B,aAAO,KAAK,QAAQ,EAAE,QAAQ,qBAAqB,SAAS,eAAqC,CAAC;AAAA,IACnG;AAEA,UAAM,KAAK,KAAK;AAAA,MACf,IAAIA,gBAAe;AAAA,MACnB,GAAG,KAAK,SAAS,YAAY;AAAA,IAC9B,CAAC;AAED,SAAK,kBAAkB,KAAK,IAAI;AAChC,SAAK,QAAQ;AAAA,EACd;AAAA,EAEA,MAAc,cAAcC,OAA4B,UAA0D;AACjH,UAAM,iBAAiB,IAAI,WAAWA,KAAI;AAG1C,QAAI,CAAC,UAAU;AACd,aAAO,KAAK,MAAM,KAAK,YAAY,OAAO,cAAc,CAAC;AAAA,IAC1D;AAGA,QAAI,KAAK,qBAAqB;AAC7B,aAAO,IAAI,QAAQ,CAAC,SAAS,WAAW;AACvC,gBAAQ,gBAAgB,EAAE,WAAW,MAAO,GAAG,CAAC,KAAK,WAAW;AAC/D,cAAI,KAAK;AACR,mBAAO,GAAG;AACV;AAAA,UACD;AAEA,kBAAQ,KAAK,MAAM,KAAK,YAAY,OAAO,MAAM,CAAC,CAA0B;AAAA,QAC7E,CAAC;AAAA,MACF,CAAC;AAAA,IACF;AAGA,QAAI,KAAK,SAAS;AACjB,YAAM,IAAI,eAAe;AACzB,YAAM,QACL,KAAK,KACL,eAAe,IAAI,OAAO,KAC1B,eAAe,IAAI,OAAO,KAC1B,eAAe,IAAI,OAAO,OAC1B,eAAe,IAAI,OAAO;AAE3B,YAAM,OAAQ,MAAM,YAAY;AAChC,WAAK,QAAQ,KAAKC,QAAO,KAAK,cAAc,GAAG,QAAQ,KAAK,eAAe,KAAK,UAAU;AAE1F,UAAI,KAAK,QAAQ,KAAK;AACrB,aAAK,KAAK,SAAS,GAAG,KAAK,QAAQ,MAAM,KAAK,QAAQ,MAAM,KAAK,KAAK,QAAQ,QAAQ,IAAI;AAAA,MAC3F;AAEA,UAAI,CAAC,OAAO;AACX,eAAO;AAAA,MACR;AAEA,YAAM,EAAE,OAAO,IAAI,KAAK;AACxB,UAAI,CAAC,QAAQ;AACZ,eAAO;AAAA,MACR;AAEA,aAAO,KAAK,MAAM,OAAO,WAAW,WAAW,SAAS,KAAK,YAAY,OAAO,MAAM,CAAC;AAAA,IACxF;AAEA,SAAK,MAAM;AAAA,MACV;AAAA,MACA,aAAa,SAAS,SAAS;AAAA,MAC/B,wBAAwB,KAAK,oBAAoB,SAAS;AAAA,MAC1D,YAAY,QAAQ,KAAK,OAAO,EAAE,SAAS;AAAA,IAC5C,CAAC;AAED,WAAO;AAAA,EACR;AAAA,EAEA,MAAc,UAAUD,OAAe,UAAmB;AACzD,UAAM,UAAU,MAAM,KAAK,cAAcA,OAA8B,QAAQ;AAC/E,QAAI,CAAC,SAAS;AACb;AAAA,IACD;AAEA,YAAQ,QAAQ,IAAI;AAAA,MACnB,KAAKD,gBAAe,UAAU;AAC7B,YAAI,KAAK,WAAW,kBAA+B;AAClD,eAAK;AAAA,QACN;AAGA,gBAAQ,QAAQ,GAAG;AAAA,UAClB,KAAK,sBAAsB,OAAO;AACjC,iBAAK,KAAK,qBAA4B,EAAE,MAAM,QAAQ,EAAE,CAAC;AAEzD,iBAAK,YAAY;AAAA,cAChB,UAAU,QAAQ;AAAA,cAClB,WAAW,QAAQ,EAAE;AAAA,cACrB,SAAS,KAAK;AAAA,cACd,YAAY,KAAK,SAAS,QAAQ;AAAA,cAClC,WAAW,QAAQ,EAAE;AAAA,YACtB;AAEA,kBAAM,KAAK,SAAS,kBAAkB,KAAK,IAAI,KAAK,OAAO;AAC3D;AAAA,UACD;AAAA,UAEA,KAAK,sBAAsB,SAAS;AACnC,iBAAK,SAAS;AACd,iBAAK,MAAM,CAAC,wBAAwB,KAAK,uBAAuB,CAAC;AACjE,iBAAK,KAAK,uBAA4B;AACtC;AAAA,UACD;AAAA,UAEA,SAAS;AACR;AAAA,UACD;AAAA,QACD;AAEA,YAAI,KAAK,WAAW,QAAQ,IAAI,KAAK,QAAQ,UAAU;AACtD,eAAK,QAAQ,WAAW,QAAQ;AAChC,gBAAM,KAAK,SAAS,kBAAkB,KAAK,IAAI,KAAK,OAAO;AAAA,QAC5D;AAEA,aAAK,KAAK,2BAA+B,EAAE,MAAM,QAAQ,CAAC;AAE1D;AAAA,MACD;AAAA,MAEA,KAAKA,gBAAe,WAAW;AAC9B,cAAM,KAAK,UAAU,IAAI;AACzB;AAAA,MACD;AAAA,MAEA,KAAKA,gBAAe,WAAW;AAC9B,cAAM,KAAK,QAAQ;AAAA,UAClB,QAAQ;AAAA,UACR,SAAS;AAAA,QACV,CAAC;AACD;AAAA,MACD;AAAA,MAEA,KAAKA,gBAAe,gBAAgB;AACnC,cAAM,eAAe,KAAK,SAAS,IAAI,mBAA0B;AACjE,sBAAc,QAAQ;AACtB,aAAK,MAAM,CAAC,4CAA4C,QAAQ,EAAE,SAAS,GAAG,CAAC;AAC/E,cAAM,UAAU,KAAK,WAAY,MAAM,KAAK,SAAS,oBAAoB,KAAK,EAAE;AAChF,YAAI,QAAQ,KAAK,SAAS;AACzB,gBAAM,KAAK,OAAO,OAAO;AAAA,QAC1B,OAAO;AACN,gBAAM,KAAK,QAAQ;AAAA,YAClB,QAAQ;AAAA,YACR,SAAS;AAAA,UACV,CAAC;AAAA,QACF;AAEA;AAAA,MACD;AAAA,MAEA,KAAKA,gBAAe,OAAO;AAC1B,aAAK,KAAK,mBAA0B;AACpC,aAAK,MAAM,CAAC,+BAA+B,QAAQ,EAAE,sBAAsB,CAAC;AAC5E,aAAK,oBAAoB,YAAY,MAAM,KAAK,KAAK,UAAU,GAAG,QAAQ,EAAE,kBAAkB;AAC9F;AAAA,MACD;AAAA,MAEA,KAAKA,gBAAe,cAAc;AACjC,aAAK,QAAQ;AACb,aAAK,MAAM,CAAC,2BAA2B,KAAK,IAAI,IAAI,KAAK,mBAAmB,CAAC;AAC7E;AAAA,MACD;AAAA,IACD;AAAA,EACD;AAAA,EAEQ,QAAQ,KAAY;AAC3B,SAAK,KAAK,SAAS,GAAG;AAAA,EACvB;AAAA,EAEA,MAAc,QAAQ,MAAc;AACnC,SAAK,KAAK,uBAA6B,EAAE,KAAK,CAAC;AAE/C,YAAQ,MAAM;AAAA,MACb,KAAK,kBAAmB;AACvB,eAAO,KAAK,QAAQ;AAAA,UACnB;AAAA,UACA,QAAQ;AAAA,UACR,SAAS;AAAA,QACV,CAAC;AAAA,MACF;AAAA,MAEA,KAAK,qBAAqB;AACzB;AAAA,MACD;AAAA,MAEA,KAAK,kBAAkB,cAAc;AACpC,aAAK,MAAM,CAAC,6BAA6B,MAAM,CAAC;AAChD,eAAO,KAAK,QAAQ,EAAE,MAAM,SAAS,eAAqC,CAAC;AAAA,MAC5E;AAAA,MAEA,KAAK,kBAAkB,eAAe;AACrC,aAAK,MAAM,CAAC,wCAAwC,CAAC;AACrD,eAAO,KAAK,QAAQ,EAAE,MAAM,SAAS,eAAqC,CAAC;AAAA,MAC5E;AAAA,MAEA,KAAK,kBAAkB,aAAa;AACnC,aAAK,MAAM,CAAC,yCAAyC,CAAC;AACtD,eAAO,KAAK,QAAQ,EAAE,MAAM,SAAS,eAAqC,CAAC;AAAA,MAC5E;AAAA,MAEA,KAAK,kBAAkB,kBAAkB;AACxC,aAAK,MAAM,CAAC,gEAAgE,CAAC;AAC7E,eAAO,KAAK,QAAQ,EAAE,MAAM,SAAS,kBAAwC,CAAC;AAAA,MAC/E;AAAA,MAEA,KAAK,kBAAkB,sBAAsB;AAC5C,cAAM,IAAI,MAAM,uBAAuB;AAAA,MACxC;AAAA,MAEA,KAAK,kBAAkB,sBAAsB;AAC5C,aAAK,MAAM,CAAC,sCAAsC,CAAC;AACnD,eAAO,KAAK,QAAQ,EAAE,MAAM,SAAS,kBAAwC,CAAC;AAAA,MAC/E;AAAA,MAEA,KAAK,kBAAkB,YAAY;AAClC,aAAK,MAAM,CAAC,+BAA+B,CAAC;AAC5C,eAAO,KAAK,QAAQ,EAAE,MAAM,SAAS,kBAAwC,CAAC;AAAA,MAC/E;AAAA,MAEA,KAAK,kBAAkB,aAAa;AACnC,aAAK,MAAM,CAAC,iEAAiE,CAAC;AAC9E,eAAO,KAAK,QAAQ,EAAE,MAAM,SAAS,kBAAwC,CAAC;AAAA,MAC/E;AAAA,MAEA,KAAK,kBAAkB,iBAAiB;AACvC,aAAK,MAAM,CAAC,oBAAoB,CAAC;AACjC,eAAO,KAAK,QAAQ,EAAE,MAAM,SAAS,eAAqC,CAAC;AAAA,MAC5E;AAAA,MAEA,KAAK,kBAAkB,cAAc;AACpC,cAAM,IAAI,MAAM,eAAe;AAAA,MAChC;AAAA,MAEA,KAAK,kBAAkB,kBAAkB;AACxC,cAAM,IAAI,MAAM,sBAAsB;AAAA,MACvC;AAAA,MAEA,KAAK,kBAAkB,mBAAmB;AACzC,cAAM,IAAI,MAAM,6BAA6B;AAAA,MAC9C;AAAA,MAEA,KAAK,kBAAkB,gBAAgB;AACtC,cAAM,IAAI,MAAM,sBAAsB;AAAA,MACvC;AAAA,MAEA,KAAK,kBAAkB,mBAAmB;AACzC,cAAM,IAAI,MAAM,yBAAyB;AAAA,MAC1C;AAAA,MAEA,SAAS;AACR,aAAK,MAAM,CAAC,8CAA8C,6BAA6B,CAAC;AACxF,eAAO,KAAK,QAAQ,EAAE,MAAM,SAAS,eAAqC,CAAC;AAAA,MAC5E;AAAA,IACD;AAAA,EACD;AAAA,EAEQ,MAAM,UAAiC;AAC9C,UAAM,UAAU,GAAG,SAAS,KAC3B,SAAS,SAAS,IACf;AAAA,EAAK,SACJ,MAAM,CAAC,EACP,IAAI,CAAC,MAAM,IAAI,GAAG,EAClB,KAAK,IAAI,MACV;AAGJ,SAAK,KAAK,qBAA4B,EAAE,QAAQ,CAAC;AAAA,EAClD;AACD;AAvhBa;;;AE9Eb,SAAS,cAAc,kBAAkB;AACzC,SAAS,cAAAG,mBAAkB;;;ACD3B,SAAS,QAAAC,aAAY;AACrB,SAAS,YAAY;AACrB,SAAS,cAAc;AACvB,SAAS,cAAAC,mBAAkB;;;ACH3B,SAAS,cAAcC,cAAa;AACpC,SAAS,cAAAC,mBAAkB;;;AFUpB,IAAM,gCAAN,MAAwE;AAAA,EAKvE,YAA4B,SAAkC;AAAlC;AAClC,QAAI,cAAc;AACjB,YAAM,IAAI,MAAM,qEAAqE;AAAA,IACtF;AAEA,eAAY,GAAG,WAAW,CAAC,YAA+B;AACzD,UAAI,QAAQ,oCAAgD;AAC3D,aAAK,gBAAgB,IAAI,QAAQ,KAAK,IAAI,QAAQ,OAAO;AACzD,aAAK,gBAAgB,OAAO,QAAQ,KAAK;AAAA,MAC1C;AAEA,UAAI,QAAQ,iCAA6C;AACxD,aAAK,wBAAwB,IAAI,QAAQ,KAAK,IAAI;AAClD,aAAK,wBAAwB,OAAO,QAAQ,KAAK;AAAA,MAClD;AAAA,IACD,CAAC;AAAA,EACF;AAAA,EApBiB,kBAAkB,IAAIC,YAA0D;AAAA,EAEhF,0BAA0B,IAAIA,YAA+B;AAAA,EAoB9E,MAAa,oBAAoB,SAA8C;AAC9E,UAAM,QAAQ,KAAK,OAAO;AAC1B,UAAM,UAAU;AAAA,MACf;AAAA,MACA;AAAA,MACA;AAAA,IACD;AAEA,UAAM,UAAU,IAAI,QAA4B,CAAC,YAAY,KAAK,gBAAgB,IAAI,OAAO,OAAO,CAAC;AACrG,eAAY,YAAY,OAAO;AAC/B,WAAO;AAAA,EACR;AAAA,EAEO,kBAAkB,SAAiB,aAAiC;AAC1E,UAAM,UAAU;AAAA,MACf;AAAA,MACA;AAAA,MACA,SAAS;AAAA,IACV;AACA,eAAY,YAAY,OAAO;AAAA,EAChC;AAAA,EAEA,MAAa,kBAAiC;AAC7C,UAAM,QAAQ,KAAK,OAAO;AAC1B,UAAM,UAAU;AAAA,MACf;AAAA,MACA;AAAA,IACD;AAEA,UAAM,UAAU,IAAI,QAAc,CAAC,YAAY,KAAK,wBAAwB,IAAI,OAAO,OAAO,CAAC;AAC/F,eAAY,YAAY,OAAO;AAC/B,WAAO;AAAA,EACR;AACD;AAxDa;;;AHCb,IAAIC,eAAc;AACjB,QAAM,IAAI,MAAM,6DAA6D;AAC9E;AAEA,IAAM,OAAO;AACb,IAAM,SAAS,IAAIC,YAAmC;AAEtD,eAAe,QAAQ,SAAiB;AACvC,QAAM,QAAQ,OAAO,IAAI,OAAO;AAChC,MAAI,CAAC,OAAO;AACX,UAAM,IAAI,MAAM,SAAS,wBAAwB;AAAA,EAClD;AAEA,QAAM,MAAM,QAAQ;AACrB;AAPe;AASf,eAAe,QAAQ,SAAiB,SAAwC;AAC/E,QAAM,QAAQ,OAAO,IAAI,OAAO;AAChC,MAAI,CAAC,OAAO;AACX,UAAM,IAAI,MAAM,SAAS,wBAAwB;AAAA,EAClD;AAEA,QAAM,MAAM,QAAQ,OAAO;AAC5B;AAPe;AASf,WAAW,WAAW,KAAK,UAAU;AACpC,QAAM,QAAQ,IAAI,eAAe,IAAI,8BAA8B,IAAI,GAAG,OAAO;AACjF,aAAW,SAAS,OAAO,OAAO,oBAAoB,GAAG;AAExD,UAAM,GAAG,OAAO,CAACC,UAAS;AACzB,YAAM,UAAU;AAAA,QACf;AAAA,QACA;AAAA,QACA,MAAAA;AAAA,QACA;AAAA,MACD;AACA,MAAAC,YAAY,YAAY,OAAO;AAAA,IAChC,CAAC;AAAA,EACF;AAEA,SAAO,IAAI,SAAS,KAAK;AAC1B;AAEAA,YACE,GAAG,gBAAgB,CAAC,QAAQ;AAC5B,QAAM;AACP,CAAC,EACA,GAAG,WAAW,OAAO,YAA+B;AACpD,UAAQ,QAAQ,IAAI;AAAA,IACnB,sBAAkC;AACjC,YAAM,QAAQ,QAAQ,OAAO;AAC7B,YAAM,WAAiC;AAAA,QACtC;AAAA,QACA,SAAS,QAAQ;AAAA,MAClB;AACA,MAAAA,YAAY,YAAY,QAAQ;AAChC;AAAA,IACD;AAAA,IAEA,sBAAkC;AACjC,YAAM,QAAQ,QAAQ,SAAS,QAAQ,OAAO;AAC9C,YAAM,WAAiC;AAAA,QACtC;AAAA,QACA,SAAS,QAAQ;AAAA,MAClB;AAEA,MAAAA,YAAY,YAAY,QAAQ;AAChC;AAAA,IACD;AAAA,IAEA,mBAA+B;AAC9B,YAAM,QAAQ,OAAO,IAAI,QAAQ,OAAO;AACxC,UAAI,CAAC,OAAO;AACX,cAAM,IAAI,MAAM,SAAS,QAAQ,wBAAwB;AAAA,MAC1D;AAEA,YAAM,MAAM,KAAK,QAAQ,OAAO;AAChC;AAAA,IACD;AAAA,IAEA,kCAA8C;AAC7C;AAAA,IACD;AAAA,IAEA,+BAA2C;AAC1C;AAAA,IACD;AAAA,EACD;AACD,CAAC;","names":["isMainThread","parentPort","Collection","Buffer","Collection","lazy","GatewayOpcodes","lazy","WebSocketShardEvents","WebSocketShardDestroyRecovery","Collection","GatewayOpcodes","data","Buffer","Collection","once","Collection","sleep","AsyncQueue","Collection","isMainThread","Collection","data","parentPort"]}