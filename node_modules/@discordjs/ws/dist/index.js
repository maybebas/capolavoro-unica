"use strict";
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __name = (target, value) => __defProp(target, "name", { value, configurable: true });
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var __publicField = (obj, key, value) => {
  __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
  return value;
};

// src/index.ts
var src_exports = {};
__export(src_exports, {
  CloseCodes: () => CloseCodes,
  CompressionMethod: () => CompressionMethod,
  DefaultDeviceProperty: () => DefaultDeviceProperty,
  DefaultWebSocketManagerOptions: () => DefaultWebSocketManagerOptions,
  Encoding: () => Encoding,
  IdentifyThrottler: () => IdentifyThrottler,
  ImportantGatewayOpcodes: () => ImportantGatewayOpcodes,
  SimpleContextFetchingStrategy: () => SimpleContextFetchingStrategy,
  SimpleShardingStrategy: () => SimpleShardingStrategy,
  WebSocketManager: () => WebSocketManager,
  WebSocketShard: () => WebSocketShard,
  WebSocketShardDestroyRecovery: () => WebSocketShardDestroyRecovery,
  WebSocketShardEvents: () => WebSocketShardEvents,
  WebSocketShardStatus: () => WebSocketShardStatus,
  WorkerContextFetchingStrategy: () => WorkerContextFetchingStrategy,
  WorkerRecievePayloadOp: () => WorkerRecievePayloadOp,
  WorkerSendPayloadOp: () => WorkerSendPayloadOp,
  WorkerShardingStrategy: () => WorkerShardingStrategy,
  getInitialSendRateLimitState: () => getInitialSendRateLimitState,
  managerToFetchingStrategyOptions: () => managerToFetchingStrategyOptions,
  version: () => version
});
module.exports = __toCommonJS(src_exports);

// src/strategies/context/IContextFetchingStrategy.ts
async function managerToFetchingStrategyOptions(manager) {
  const { retrieveSessionInfo, updateSessionInfo, shardCount, shardIds, rest, ...managerOptions } = manager.options;
  return {
    ...managerOptions,
    gatewayInformation: await manager.fetchGatewayInformation(),
    shardCount: await manager.getShardCount()
  };
}
__name(managerToFetchingStrategyOptions, "managerToFetchingStrategyOptions");

// src/utils/IdentifyThrottler.ts
var import_promises = require("timers/promises");
var import_async_queue = require("@sapphire/async-queue");
var IdentifyThrottler = class {
  constructor(manager) {
    this.manager = manager;
  }
  queue = new import_async_queue.AsyncQueue();
  identifyState = {
    remaining: 0,
    resetsAt: Number.POSITIVE_INFINITY
  };
  async waitForIdentify() {
    await this.queue.wait();
    try {
      if (this.identifyState.remaining <= 0) {
        const diff = this.identifyState.resetsAt - Date.now();
        if (diff <= 5e3) {
          const time = diff + Math.random() * 1500;
          await (0, import_promises.setTimeout)(time);
        }
        const info = await this.manager.fetchGatewayInformation();
        this.identifyState = {
          remaining: info.session_start_limit.max_concurrency,
          resetsAt: Date.now() + 5e3
        };
      }
      this.identifyState.remaining--;
    } finally {
      this.queue.shift();
    }
  }
};
__name(IdentifyThrottler, "IdentifyThrottler");

// src/strategies/context/SimpleContextFetchingStrategy.ts
var _SimpleContextFetchingStrategy = class {
  constructor(manager, options) {
    this.manager = manager;
    this.options = options;
    this.throttler = _SimpleContextFetchingStrategy.ensureThrottler(manager);
  }
  static ensureThrottler(manager) {
    const existing = _SimpleContextFetchingStrategy.throttlerCache.get(manager);
    if (existing) {
      return existing;
    }
    const throttler = new IdentifyThrottler(manager);
    _SimpleContextFetchingStrategy.throttlerCache.set(manager, throttler);
    return throttler;
  }
  throttler;
  async retrieveSessionInfo(shardId) {
    return this.manager.options.retrieveSessionInfo(shardId);
  }
  updateSessionInfo(shardId, sessionInfo) {
    return this.manager.options.updateSessionInfo(shardId, sessionInfo);
  }
  async waitForIdentify() {
    await this.throttler.waitForIdentify();
  }
};
var SimpleContextFetchingStrategy = _SimpleContextFetchingStrategy;
__name(SimpleContextFetchingStrategy, "SimpleContextFetchingStrategy");
__publicField(SimpleContextFetchingStrategy, "throttlerCache", /* @__PURE__ */ new WeakMap());

// src/strategies/context/WorkerContextFetchingStrategy.ts
var import_node_worker_threads2 = require("worker_threads");
var import_collection2 = require("@discordjs/collection");

// src/strategies/sharding/WorkerShardingStrategy.ts
var import_node_events = require("events");
var import_node_path = require("path");
var import_node_worker_threads = require("worker_threads");
var import_collection = require("@discordjs/collection");
var WorkerSendPayloadOp = /* @__PURE__ */ ((WorkerSendPayloadOp2) => {
  WorkerSendPayloadOp2[WorkerSendPayloadOp2["Connect"] = 0] = "Connect";
  WorkerSendPayloadOp2[WorkerSendPayloadOp2["Destroy"] = 1] = "Destroy";
  WorkerSendPayloadOp2[WorkerSendPayloadOp2["Send"] = 2] = "Send";
  WorkerSendPayloadOp2[WorkerSendPayloadOp2["SessionInfoResponse"] = 3] = "SessionInfoResponse";
  WorkerSendPayloadOp2[WorkerSendPayloadOp2["ShardCanIdentify"] = 4] = "ShardCanIdentify";
  return WorkerSendPayloadOp2;
})(WorkerSendPayloadOp || {});
var WorkerRecievePayloadOp = /* @__PURE__ */ ((WorkerRecievePayloadOp2) => {
  WorkerRecievePayloadOp2[WorkerRecievePayloadOp2["Connected"] = 0] = "Connected";
  WorkerRecievePayloadOp2[WorkerRecievePayloadOp2["Destroyed"] = 1] = "Destroyed";
  WorkerRecievePayloadOp2[WorkerRecievePayloadOp2["Event"] = 2] = "Event";
  WorkerRecievePayloadOp2[WorkerRecievePayloadOp2["RetrieveSessionInfo"] = 3] = "RetrieveSessionInfo";
  WorkerRecievePayloadOp2[WorkerRecievePayloadOp2["UpdateSessionInfo"] = 4] = "UpdateSessionInfo";
  WorkerRecievePayloadOp2[WorkerRecievePayloadOp2["WaitForIdentify"] = 5] = "WaitForIdentify";
  return WorkerRecievePayloadOp2;
})(WorkerRecievePayloadOp || {});
var WorkerShardingStrategy = class {
  manager;
  options;
  #workers = [];
  #workerByShardId = new import_collection.Collection();
  connectPromises = new import_collection.Collection();
  destroyPromises = new import_collection.Collection();
  throttler;
  constructor(manager, options) {
    this.manager = manager;
    this.throttler = new IdentifyThrottler(manager);
    this.options = options;
  }
  async spawn(shardIds) {
    const shardsPerWorker = this.options.shardsPerWorker === "all" ? shardIds.length : this.options.shardsPerWorker;
    const strategyOptions = await managerToFetchingStrategyOptions(this.manager);
    let shards = 0;
    while (shards !== shardIds.length) {
      const slice = shardIds.slice(shards, shardsPerWorker + shards);
      const workerData = {
        ...strategyOptions,
        shardIds: slice
      };
      const worker = new import_node_worker_threads.Worker((0, import_node_path.join)(__dirname, "worker.js"), { workerData });
      await (0, import_node_events.once)(worker, "online");
      worker.on("error", (err) => {
        throw err;
      }).on("messageerror", (err) => {
        throw err;
      }).on("message", async (payload) => this.onMessage(worker, payload));
      this.#workers.push(worker);
      for (const shardId of slice) {
        this.#workerByShardId.set(shardId, worker);
      }
      shards += slice.length;
    }
  }
  async connect() {
    const promises = [];
    for (const [shardId, worker] of this.#workerByShardId.entries()) {
      const payload = {
        op: 0 /* Connect */,
        shardId
      };
      const promise = new Promise((resolve) => this.connectPromises.set(shardId, resolve));
      worker.postMessage(payload);
      promises.push(promise);
    }
    await Promise.all(promises);
  }
  async destroy(options = {}) {
    const promises = [];
    for (const [shardId, worker] of this.#workerByShardId.entries()) {
      const payload = {
        op: 1 /* Destroy */,
        shardId,
        options
      };
      promises.push(
        new Promise((resolve) => this.destroyPromises.set(shardId, resolve)).then(async () => worker.terminate())
      );
      worker.postMessage(payload);
    }
    this.#workers = [];
    this.#workerByShardId.clear();
    await Promise.all(promises);
  }
  send(shardId, data) {
    const worker = this.#workerByShardId.get(shardId);
    if (!worker) {
      throw new Error(`No worker found for shard ${shardId}`);
    }
    const payload = {
      op: 2 /* Send */,
      shardId,
      payload: data
    };
    worker.postMessage(payload);
  }
  async onMessage(worker, payload) {
    switch (payload.op) {
      case 0 /* Connected */: {
        const resolve = this.connectPromises.get(payload.shardId);
        resolve();
        this.connectPromises.delete(payload.shardId);
        break;
      }
      case 1 /* Destroyed */: {
        const resolve = this.destroyPromises.get(payload.shardId);
        resolve();
        this.destroyPromises.delete(payload.shardId);
        break;
      }
      case 2 /* Event */: {
        this.manager.emit(payload.event, { ...payload.data, shardId: payload.shardId });
        break;
      }
      case 3 /* RetrieveSessionInfo */: {
        const session = await this.manager.options.retrieveSessionInfo(payload.shardId);
        const response = {
          op: 3 /* SessionInfoResponse */,
          nonce: payload.nonce,
          session
        };
        worker.postMessage(response);
        break;
      }
      case 4 /* UpdateSessionInfo */: {
        await this.manager.options.updateSessionInfo(payload.shardId, payload.session);
        break;
      }
      case 5 /* WaitForIdentify */: {
        await this.throttler.waitForIdentify();
        const response = {
          op: 4 /* ShardCanIdentify */,
          nonce: payload.nonce
        };
        worker.postMessage(response);
        break;
      }
    }
  }
};
__name(WorkerShardingStrategy, "WorkerShardingStrategy");

// src/strategies/context/WorkerContextFetchingStrategy.ts
var WorkerContextFetchingStrategy = class {
  constructor(options) {
    this.options = options;
    if (import_node_worker_threads2.isMainThread) {
      throw new Error("Cannot instantiate WorkerContextFetchingStrategy on the main thread");
    }
    import_node_worker_threads2.parentPort.on("message", (payload) => {
      if (payload.op === 3 /* SessionInfoResponse */) {
        this.sessionPromises.get(payload.nonce)?.(payload.session);
        this.sessionPromises.delete(payload.nonce);
      }
      if (payload.op === 4 /* ShardCanIdentify */) {
        this.waitForIdentifyPromises.get(payload.nonce)?.();
        this.waitForIdentifyPromises.delete(payload.nonce);
      }
    });
  }
  sessionPromises = new import_collection2.Collection();
  waitForIdentifyPromises = new import_collection2.Collection();
  async retrieveSessionInfo(shardId) {
    const nonce = Math.random();
    const payload = {
      op: 3 /* RetrieveSessionInfo */,
      shardId,
      nonce
    };
    const promise = new Promise((resolve) => this.sessionPromises.set(nonce, resolve));
    import_node_worker_threads2.parentPort.postMessage(payload);
    return promise;
  }
  updateSessionInfo(shardId, sessionInfo) {
    const payload = {
      op: 4 /* UpdateSessionInfo */,
      shardId,
      session: sessionInfo
    };
    import_node_worker_threads2.parentPort.postMessage(payload);
  }
  async waitForIdentify() {
    const nonce = Math.random();
    const payload = {
      op: 5 /* WaitForIdentify */,
      nonce
    };
    const promise = new Promise((resolve) => this.waitForIdentifyPromises.set(nonce, resolve));
    import_node_worker_threads2.parentPort.postMessage(payload);
    return promise;
  }
};
__name(WorkerContextFetchingStrategy, "WorkerContextFetchingStrategy");

// src/strategies/sharding/SimpleShardingStrategy.ts
var import_collection5 = require("@discordjs/collection");

// src/ws/WebSocketShard.ts
var import_node_buffer = require("buffer");
var import_node_events2 = require("events");
var import_node_timers = require("timers");
var import_promises2 = require("timers/promises");
var import_node_url = require("url");
var import_node_util = require("util");
var import_node_zlib = require("zlib");
var import_collection4 = require("@discordjs/collection");
var import_util2 = require("@discordjs/util");
var import_async_queue2 = require("@sapphire/async-queue");
var import_async_event_emitter = require("@vladfrangu/async_event_emitter");
var import_v102 = require("discord-api-types/v10");
var import_ws = require("ws");

// src/utils/constants.ts
var import_node_process = __toESM(require("process"));
var import_collection3 = require("@discordjs/collection");
var import_util = require("@discordjs/util");
var import_v10 = require("discord-api-types/v10");
var Encoding = /* @__PURE__ */ ((Encoding2) => {
  Encoding2["JSON"] = "json";
  return Encoding2;
})(Encoding || {});
var CompressionMethod = /* @__PURE__ */ ((CompressionMethod2) => {
  CompressionMethod2["ZlibStream"] = "zlib-stream";
  return CompressionMethod2;
})(CompressionMethod || {});
var DefaultDeviceProperty = `@discordjs/ws 0.6.0`;
var getDefaultSessionStore = (0, import_util.lazy)(() => new import_collection3.Collection());
var DefaultWebSocketManagerOptions = {
  shardCount: null,
  shardIds: null,
  largeThreshold: null,
  initialPresence: null,
  identifyProperties: {
    browser: DefaultDeviceProperty,
    device: DefaultDeviceProperty,
    os: import_node_process.default.platform
  },
  version: import_v10.APIVersion,
  encoding: "json" /* JSON */,
  compression: null,
  retrieveSessionInfo(shardId) {
    const store = getDefaultSessionStore();
    return store.get(shardId) ?? null;
  },
  updateSessionInfo(shardId, info) {
    const store = getDefaultSessionStore();
    if (info) {
      store.set(shardId, info);
    } else {
      store.delete(shardId);
    }
  },
  handshakeTimeout: 3e4,
  helloTimeout: 6e4,
  readyTimeout: 15e3
};
var ImportantGatewayOpcodes = /* @__PURE__ */ new Set([
  import_v10.GatewayOpcodes.Heartbeat,
  import_v10.GatewayOpcodes.Identify,
  import_v10.GatewayOpcodes.Resume
]);
function getInitialSendRateLimitState() {
  return {
    remaining: 120,
    resetAt: Date.now() + 6e4
  };
}
__name(getInitialSendRateLimitState, "getInitialSendRateLimitState");

// src/ws/WebSocketShard.ts
var getZlibSync = (0, import_util2.lazy)(async () => import("zlib-sync").then((mod) => mod.default).catch(() => null));
var WebSocketShardEvents = /* @__PURE__ */ ((WebSocketShardEvents2) => {
  WebSocketShardEvents2["Closed"] = "closed";
  WebSocketShardEvents2["Debug"] = "debug";
  WebSocketShardEvents2["Dispatch"] = "dispatch";
  WebSocketShardEvents2["Hello"] = "hello";
  WebSocketShardEvents2["Ready"] = "ready";
  WebSocketShardEvents2["Resumed"] = "resumed";
  return WebSocketShardEvents2;
})(WebSocketShardEvents || {});
var WebSocketShardStatus = /* @__PURE__ */ ((WebSocketShardStatus2) => {
  WebSocketShardStatus2[WebSocketShardStatus2["Idle"] = 0] = "Idle";
  WebSocketShardStatus2[WebSocketShardStatus2["Connecting"] = 1] = "Connecting";
  WebSocketShardStatus2[WebSocketShardStatus2["Resuming"] = 2] = "Resuming";
  WebSocketShardStatus2[WebSocketShardStatus2["Ready"] = 3] = "Ready";
  return WebSocketShardStatus2;
})(WebSocketShardStatus || {});
var WebSocketShardDestroyRecovery = /* @__PURE__ */ ((WebSocketShardDestroyRecovery2) => {
  WebSocketShardDestroyRecovery2[WebSocketShardDestroyRecovery2["Reconnect"] = 0] = "Reconnect";
  WebSocketShardDestroyRecovery2[WebSocketShardDestroyRecovery2["Resume"] = 1] = "Resume";
  return WebSocketShardDestroyRecovery2;
})(WebSocketShardDestroyRecovery || {});
var CloseCodes = /* @__PURE__ */ ((CloseCodes2) => {
  CloseCodes2[CloseCodes2["Normal"] = 1e3] = "Normal";
  CloseCodes2[CloseCodes2["Resuming"] = 4200] = "Resuming";
  return CloseCodes2;
})(CloseCodes || {});
var WebSocketShard = class extends import_async_event_emitter.AsyncEventEmitter {
  connection = null;
  id;
  useIdentifyCompress = false;
  inflate = null;
  textDecoder = new import_node_util.TextDecoder();
  status = 0 /* Idle */;
  replayedEvents = 0;
  isAck = true;
  sendRateLimitState = getInitialSendRateLimitState();
  heartbeatInterval = null;
  lastHeartbeatAt = -1;
  session = null;
  sendQueue = new import_async_queue2.AsyncQueue();
  timeouts = new import_collection4.Collection();
  strategy;
  constructor(strategy, id) {
    super();
    this.strategy = strategy;
    this.id = id;
  }
  async connect() {
    if (this.status !== 0 /* Idle */) {
      throw new Error("Tried to connect a shard that wasn't idle");
    }
    const { version: version2, encoding, compression } = this.strategy.options;
    const params = new import_node_url.URLSearchParams({ v: version2, encoding });
    if (compression) {
      const zlib = await getZlibSync();
      if (zlib) {
        params.append("compress", compression);
        this.inflate = new zlib.Inflate({
          chunkSize: 65535,
          to: "string"
        });
      } else if (!this.useIdentifyCompress) {
        this.useIdentifyCompress = true;
        console.warn(
          "WebSocketShard: Compression is enabled but zlib-sync is not installed, falling back to identify compress"
        );
      }
    }
    const session = this.session ?? await this.strategy.retrieveSessionInfo(this.id);
    const url = `${session?.resumeURL ?? this.strategy.options.gatewayInformation.url}?${params.toString()}`;
    this.debug([`Connecting to ${url}`]);
    const connection = new import_ws.WebSocket(url, { handshakeTimeout: this.strategy.options.handshakeTimeout ?? void 0 }).on("message", this.onMessage.bind(this)).on("error", this.onError.bind(this)).on("close", this.onClose.bind(this));
    connection.binaryType = "arraybuffer";
    this.connection = connection;
    this.status = 1 /* Connecting */;
    this.sendRateLimitState = getInitialSendRateLimitState();
    await this.waitForEvent("hello" /* Hello */, this.strategy.options.helloTimeout);
    if (session?.shardCount === this.strategy.options.shardCount) {
      this.session = session;
      await this.resume(session);
    } else {
      await this.identify();
    }
  }
  async destroy(options = {}) {
    if (this.status === 0 /* Idle */) {
      this.debug(["Tried to destroy a shard that was idle"]);
      return;
    }
    if (!options.code) {
      options.code = options.recover === 1 /* Resume */ ? 4200 /* Resuming */ : 1e3 /* Normal */;
    }
    this.debug([
      "Destroying shard",
      `Reason: ${options.reason ?? "none"}`,
      `Code: ${options.code}`,
      `Recover: ${options.recover === void 0 ? "none" : WebSocketShardDestroyRecovery[options.recover]}`
    ]);
    this.isAck = true;
    if (this.heartbeatInterval) {
      (0, import_node_timers.clearInterval)(this.heartbeatInterval);
    }
    this.lastHeartbeatAt = -1;
    if (options.recover !== 1 /* Resume */ && this.session) {
      this.session = null;
      await this.strategy.updateSessionInfo(this.id, null);
    }
    if (this.connection) {
      this.connection.removeAllListeners("message");
      this.connection.removeAllListeners("close");
      const shouldClose = this.connection.readyState === import_ws.WebSocket.OPEN || this.connection.readyState === import_ws.WebSocket.CONNECTING;
      this.debug([
        "Connection status during destroy",
        `Needs closing: ${shouldClose}`,
        `Ready state: ${this.connection.readyState}`
      ]);
      if (shouldClose) {
        this.connection.close(options.code, options.reason);
        await (0, import_node_events2.once)(this.connection, "close");
        this.emit("closed" /* Closed */, { code: options.code });
      }
      this.connection.removeAllListeners("error");
    } else {
      this.debug(["Destroying a shard that has no connection; please open an issue on GitHub"]);
    }
    this.status = 0 /* Idle */;
    if (options.recover !== void 0) {
      return this.connect();
    }
  }
  async waitForEvent(event, timeoutDuration) {
    this.debug([`Waiting for event ${event} for ${timeoutDuration ? `${timeoutDuration}ms` : "indefinitely"}`]);
    const controller = new AbortController();
    const timeout = timeoutDuration ? (0, import_node_timers.setTimeout)(() => controller.abort(), timeoutDuration).unref() : null;
    if (timeout) {
      this.timeouts.set(event, timeout);
    }
    await (0, import_node_events2.once)(this, event, { signal: controller.signal });
    if (timeout) {
      (0, import_node_timers.clearTimeout)(timeout);
      this.timeouts.delete(event);
    }
  }
  async send(payload) {
    if (!this.connection) {
      throw new Error("WebSocketShard wasn't connected");
    }
    if (this.status !== 3 /* Ready */ && !ImportantGatewayOpcodes.has(payload.op)) {
      this.debug(["Tried to send a non-crucial payload before the shard was ready, waiting"]);
      await (0, import_node_events2.once)(this, "ready" /* Ready */);
    }
    await this.sendQueue.wait();
    if (--this.sendRateLimitState.remaining <= 0) {
      const now = Date.now();
      if (this.sendRateLimitState.resetAt > now) {
        const sleepFor = this.sendRateLimitState.resetAt - now;
        this.debug([`Was about to hit the send rate limit, sleeping for ${sleepFor}ms`]);
        const controller = new AbortController();
        const interrupted = await Promise.race([
          (0, import_promises2.setTimeout)(sleepFor).then(() => false),
          (0, import_node_events2.once)(this, "closed" /* Closed */, { signal: controller.signal }).then(() => true)
        ]);
        if (interrupted) {
          this.debug(["Connection closed while waiting for the send rate limit to reset, re-queueing payload"]);
          this.sendQueue.shift();
          return this.send(payload);
        }
        controller.abort();
      }
      this.sendRateLimitState = getInitialSendRateLimitState();
    }
    this.sendQueue.shift();
    this.connection.send(JSON.stringify(payload));
  }
  async identify() {
    this.debug([
      "Identifying",
      `shard id: ${this.id.toString()}`,
      `shard count: ${this.strategy.options.shardCount}`,
      `intents: ${this.strategy.options.intents}`,
      `compression: ${this.inflate ? "zlib-stream" : this.useIdentifyCompress ? "identify" : "none"}`
    ]);
    await this.strategy.waitForIdentify();
    const d = {
      token: this.strategy.options.token,
      properties: this.strategy.options.identifyProperties,
      intents: this.strategy.options.intents,
      compress: this.useIdentifyCompress,
      shard: [this.id, this.strategy.options.shardCount]
    };
    if (this.strategy.options.largeThreshold) {
      d.large_threshold = this.strategy.options.largeThreshold;
    }
    if (this.strategy.options.initialPresence) {
      d.presence = this.strategy.options.initialPresence;
    }
    await this.send({
      op: import_v102.GatewayOpcodes.Identify,
      d
    });
    await this.waitForEvent("ready" /* Ready */, this.strategy.options.readyTimeout);
    this.status = 3 /* Ready */;
  }
  async resume(session) {
    this.debug(["Resuming session"]);
    this.status = 2 /* Resuming */;
    this.replayedEvents = 0;
    return this.send({
      op: import_v102.GatewayOpcodes.Resume,
      d: {
        token: this.strategy.options.token,
        seq: session.sequence,
        session_id: session.sessionId
      }
    });
  }
  async heartbeat(requested = false) {
    if (!this.isAck && !requested) {
      return this.destroy({ reason: "Zombie connection", recover: 1 /* Resume */ });
    }
    await this.send({
      op: import_v102.GatewayOpcodes.Heartbeat,
      d: this.session?.sequence ?? null
    });
    this.lastHeartbeatAt = Date.now();
    this.isAck = false;
  }
  async unpackMessage(data, isBinary) {
    const decompressable = new Uint8Array(data);
    if (!isBinary) {
      return JSON.parse(this.textDecoder.decode(decompressable));
    }
    if (this.useIdentifyCompress) {
      return new Promise((resolve, reject) => {
        (0, import_node_zlib.inflate)(decompressable, { chunkSize: 65535 }, (err, result) => {
          if (err) {
            reject(err);
            return;
          }
          resolve(JSON.parse(this.textDecoder.decode(result)));
        });
      });
    }
    if (this.inflate) {
      const l = decompressable.length;
      const flush = l >= 4 && decompressable[l - 4] === 0 && decompressable[l - 3] === 0 && decompressable[l - 2] === 255 && decompressable[l - 1] === 255;
      const zlib = await getZlibSync();
      this.inflate.push(import_node_buffer.Buffer.from(decompressable), flush ? zlib.Z_SYNC_FLUSH : zlib.Z_NO_FLUSH);
      if (this.inflate.err) {
        this.emit("error", `${this.inflate.err}${this.inflate.msg ? `: ${this.inflate.msg}` : ""}`);
      }
      if (!flush) {
        return null;
      }
      const { result } = this.inflate;
      if (!result) {
        return null;
      }
      return JSON.parse(typeof result === "string" ? result : this.textDecoder.decode(result));
    }
    this.debug([
      "Received a message we were unable to decompress",
      `isBinary: ${isBinary.toString()}`,
      `useIdentifyCompress: ${this.useIdentifyCompress.toString()}`,
      `inflate: ${Boolean(this.inflate).toString()}`
    ]);
    return null;
  }
  async onMessage(data, isBinary) {
    const payload = await this.unpackMessage(data, isBinary);
    if (!payload) {
      return;
    }
    switch (payload.op) {
      case import_v102.GatewayOpcodes.Dispatch: {
        if (this.status === 2 /* Resuming */) {
          this.replayedEvents++;
        }
        switch (payload.t) {
          case import_v102.GatewayDispatchEvents.Ready: {
            this.emit("ready" /* Ready */, { data: payload.d });
            this.session ??= {
              sequence: payload.s,
              sessionId: payload.d.session_id,
              shardId: this.id,
              shardCount: this.strategy.options.shardCount,
              resumeURL: payload.d.resume_gateway_url
            };
            await this.strategy.updateSessionInfo(this.id, this.session);
            break;
          }
          case import_v102.GatewayDispatchEvents.Resumed: {
            this.status = 3 /* Ready */;
            this.debug([`Resumed and replayed ${this.replayedEvents} events`]);
            this.emit("resumed" /* Resumed */);
            break;
          }
          default: {
            break;
          }
        }
        if (this.session && payload.s > this.session.sequence) {
          this.session.sequence = payload.s;
          await this.strategy.updateSessionInfo(this.id, this.session);
        }
        this.emit("dispatch" /* Dispatch */, { data: payload });
        break;
      }
      case import_v102.GatewayOpcodes.Heartbeat: {
        await this.heartbeat(true);
        break;
      }
      case import_v102.GatewayOpcodes.Reconnect: {
        await this.destroy({
          reason: "Told to reconnect by Discord",
          recover: 1 /* Resume */
        });
        break;
      }
      case import_v102.GatewayOpcodes.InvalidSession: {
        const readyTimeout = this.timeouts.get("ready" /* Ready */);
        readyTimeout?.refresh();
        this.debug([`Invalid session; will attempt to resume: ${payload.d.toString()}`]);
        const session = this.session ?? await this.strategy.retrieveSessionInfo(this.id);
        if (payload.d && session) {
          await this.resume(session);
        } else {
          await this.destroy({
            reason: "Invalid session",
            recover: 0 /* Reconnect */
          });
        }
        break;
      }
      case import_v102.GatewayOpcodes.Hello: {
        this.emit("hello" /* Hello */);
        this.debug([`Starting to heartbeat every ${payload.d.heartbeat_interval}ms`]);
        this.heartbeatInterval = (0, import_node_timers.setInterval)(() => void this.heartbeat(), payload.d.heartbeat_interval);
        break;
      }
      case import_v102.GatewayOpcodes.HeartbeatAck: {
        this.isAck = true;
        this.debug([`Got heartbeat ack after ${Date.now() - this.lastHeartbeatAt}ms`]);
        break;
      }
    }
  }
  onError(err) {
    this.emit("error", err);
  }
  async onClose(code) {
    this.emit("closed" /* Closed */, { code });
    switch (code) {
      case 1e3 /* Normal */: {
        return this.destroy({
          code,
          reason: "Got disconnected by Discord",
          recover: 0 /* Reconnect */
        });
      }
      case 4200 /* Resuming */: {
        break;
      }
      case import_v102.GatewayCloseCodes.UnknownError: {
        this.debug([`An unknown error occured: ${code}`]);
        return this.destroy({ code, recover: 1 /* Resume */ });
      }
      case import_v102.GatewayCloseCodes.UnknownOpcode: {
        this.debug(["An invalid opcode was sent to Discord."]);
        return this.destroy({ code, recover: 1 /* Resume */ });
      }
      case import_v102.GatewayCloseCodes.DecodeError: {
        this.debug(["An invalid payload was sent to Discord."]);
        return this.destroy({ code, recover: 1 /* Resume */ });
      }
      case import_v102.GatewayCloseCodes.NotAuthenticated: {
        this.debug(["A request was somehow sent before the identify/resume payload."]);
        return this.destroy({ code, recover: 0 /* Reconnect */ });
      }
      case import_v102.GatewayCloseCodes.AuthenticationFailed: {
        throw new Error("Authentication failed");
      }
      case import_v102.GatewayCloseCodes.AlreadyAuthenticated: {
        this.debug(["More than one auth payload was sent."]);
        return this.destroy({ code, recover: 0 /* Reconnect */ });
      }
      case import_v102.GatewayCloseCodes.InvalidSeq: {
        this.debug(["An invalid sequence was sent."]);
        return this.destroy({ code, recover: 0 /* Reconnect */ });
      }
      case import_v102.GatewayCloseCodes.RateLimited: {
        this.debug(["The WebSocket rate limit has been hit, this should never happen"]);
        return this.destroy({ code, recover: 0 /* Reconnect */ });
      }
      case import_v102.GatewayCloseCodes.SessionTimedOut: {
        this.debug(["Session timed out."]);
        return this.destroy({ code, recover: 1 /* Resume */ });
      }
      case import_v102.GatewayCloseCodes.InvalidShard: {
        throw new Error("Invalid shard");
      }
      case import_v102.GatewayCloseCodes.ShardingRequired: {
        throw new Error("Sharding is required");
      }
      case import_v102.GatewayCloseCodes.InvalidAPIVersion: {
        throw new Error("Used an invalid API version");
      }
      case import_v102.GatewayCloseCodes.InvalidIntents: {
        throw new Error("Used invalid intents");
      }
      case import_v102.GatewayCloseCodes.DisallowedIntents: {
        throw new Error("Used disallowed intents");
      }
      default: {
        this.debug([`The gateway closed with an unexpected code ${code}, attempting to resume.`]);
        return this.destroy({ code, recover: 1 /* Resume */ });
      }
    }
  }
  debug(messages) {
    const message = `${messages[0]}${messages.length > 1 ? `
${messages.slice(1).map((m) => `	${m}`).join("\n")}` : ""}`;
    this.emit("debug" /* Debug */, { message });
  }
};
__name(WebSocketShard, "WebSocketShard");

// src/strategies/sharding/SimpleShardingStrategy.ts
var SimpleShardingStrategy = class {
  manager;
  shards = new import_collection5.Collection();
  constructor(manager) {
    this.manager = manager;
  }
  async spawn(shardIds) {
    const strategyOptions = await managerToFetchingStrategyOptions(this.manager);
    for (const shardId of shardIds) {
      const strategy = new SimpleContextFetchingStrategy(this.manager, strategyOptions);
      const shard = new WebSocketShard(strategy, shardId);
      for (const event of Object.values(WebSocketShardEvents)) {
        shard.on(event, (payload) => this.manager.emit(event, { ...payload, shardId }));
      }
      this.shards.set(shardId, shard);
    }
  }
  async connect() {
    const promises = [];
    for (const shard of this.shards.values()) {
      promises.push(shard.connect());
    }
    await Promise.all(promises);
  }
  async destroy(options) {
    const promises = [];
    for (const shard of this.shards.values()) {
      promises.push(shard.destroy(options));
    }
    await Promise.all(promises);
    this.shards.clear();
  }
  async send(shardId, payload) {
    const shard = this.shards.get(shardId);
    if (!shard)
      throw new Error(`Shard ${shardId} not found`);
    return shard.send(payload);
  }
};
__name(SimpleShardingStrategy, "SimpleShardingStrategy");

// src/ws/WebSocketManager.ts
var import_util3 = require("@discordjs/util");
var import_async_event_emitter2 = require("@vladfrangu/async_event_emitter");
var import_v103 = require("discord-api-types/v10");
var WebSocketManager = class extends import_async_event_emitter2.AsyncEventEmitter {
  options;
  gatewayInformation = null;
  shardIds = null;
  strategy = new SimpleShardingStrategy(this);
  constructor(options) {
    super();
    this.options = { ...DefaultWebSocketManagerOptions, ...options };
  }
  setStrategy(strategy) {
    this.strategy = strategy;
    return this;
  }
  async fetchGatewayInformation(force = false) {
    if (this.gatewayInformation) {
      if (this.gatewayInformation.expiresAt <= Date.now()) {
        this.gatewayInformation = null;
      } else if (!force) {
        return this.gatewayInformation.data;
      }
    }
    const data = await this.options.rest.get(import_v103.Routes.gatewayBot());
    this.gatewayInformation = { data, expiresAt: Date.now() + data.session_start_limit.reset_after };
    return this.gatewayInformation.data;
  }
  async updateShardCount(shardCount) {
    await this.strategy.destroy({ reason: "User is adjusting their shards" });
    this.options.shardCount = shardCount;
    const shardIds = await this.getShardIds(true);
    await this.strategy.spawn(shardIds);
    return this;
  }
  async getShardCount() {
    if (this.options.shardCount) {
      return this.options.shardCount;
    }
    const shardIds = await this.getShardIds();
    return Math.max(...shardIds) + 1;
  }
  async getShardIds(force = false) {
    if (this.shardIds && !force) {
      return this.shardIds;
    }
    let shardIds;
    if (this.options.shardIds) {
      if (Array.isArray(this.options.shardIds)) {
        shardIds = this.options.shardIds;
      } else {
        shardIds = (0, import_util3.range)(this.options.shardIds.start, this.options.shardIds.end);
      }
    } else {
      const data = await this.fetchGatewayInformation();
      shardIds = (0, import_util3.range)(0, (this.options.shardCount ?? data.shards) - 1);
    }
    this.shardIds = shardIds;
    return shardIds;
  }
  async connect() {
    const shardCount = await this.getShardCount();
    const data = await this.fetchGatewayInformation();
    if (data.session_start_limit.remaining < shardCount) {
      throw new Error(
        `Not enough sessions remaining to spawn ${shardCount} shards; only ${data.session_start_limit.remaining} remaining; resets at ${new Date(Date.now() + data.session_start_limit.reset_after).toISOString()}`
      );
    }
    await this.updateShardCount(shardCount);
    await this.strategy.connect();
  }
  destroy(options) {
    return this.strategy.destroy(options);
  }
  send(shardId, payload) {
    return this.strategy.send(shardId, payload);
  }
};
__name(WebSocketManager, "WebSocketManager");

// src/index.ts
var version = "0.6.0";
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  CloseCodes,
  CompressionMethod,
  DefaultDeviceProperty,
  DefaultWebSocketManagerOptions,
  Encoding,
  IdentifyThrottler,
  ImportantGatewayOpcodes,
  SimpleContextFetchingStrategy,
  SimpleShardingStrategy,
  WebSocketManager,
  WebSocketShard,
  WebSocketShardDestroyRecovery,
  WebSocketShardEvents,
  WebSocketShardStatus,
  WorkerContextFetchingStrategy,
  WorkerRecievePayloadOp,
  WorkerSendPayloadOp,
  WorkerShardingStrategy,
  getInitialSendRateLimitState,
  managerToFetchingStrategyOptions,
  version
});
//# sourceMappingURL=index.js.map